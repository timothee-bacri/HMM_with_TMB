<!-- ```{r 6import-files, echo = FALSE, cache = FALSE} -->
<!-- library(knitr) -->
<!-- setwd(dir = "../") -->
<!-- # suppressMessages(source("code/main.R")) -->
<!-- knitr::read_chunk('functions/utils.R') -->
<!-- ``` -->

# Application to different data sets

## TYT dataset
We detail here the code used to estimate a 2-state Poisson HMM based on the tinnitus dataset available in *[data/tinnitus.RData](data/tinnitus.RData)*.

- Set a seed for randomness, and load files
```{r 6tyt-init}
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
load("data/tinnitus.RData")
```

- Set initial parameters
```{r 6tyt-init-params}
# Parameters and covariates
m <- 2
gamma <- matrix(c(0.8, 0.2,
                  0.2, 0.8), nrow = m, ncol = m)
lambda <- seq(quantile(tinn_data, 0.1), quantile(tinn_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
```

- Transform them into working parameters
```{r 6tyt-pn2pw}
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = tinn_data, m = m)
```

- Estimate the parameters via a function
```{r 6tyt-estim}
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
                     DLL = "poi_hmm", silent = TRUE)

# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
                  objective = obj_tmb$fn,
                  gradient = obj_tmb$gr,
                  hessian = obj_tmb$he)

# Check convergence
mod_tmb$convergence == 0

# Results
summary(sdreport(obj_tmb), "report")
```

For the code used to generate coverage probabilities and acceleration results, please take a look at *[code/poi_hmm_tinn.R](code/poi_hmm_tinn.R)*.

## Simulated dataset

We detail here the code used to simulate two datasets from 2-states Poisson HMMs, one of size \Sexpr{DATA_SIZE_SIMU1} and one of size \Sexpr{DATA_SIZE_SIMU2}.
Then, using the same procedure as above, we estimate a model using different initial parameters.

- Set initial parameters (data size and HMM parameters)
```{r 6simu-gen-init-params}
DATA_SIZE_SIMU <- 2000
m <- 2
# Generate parameters
lambda <- seq(10, 14, length.out = m)
# Create the transition probability matrix with 0.8 on its diagonal
gamma <- matrix(c(0.8, 0.2,
                  0.2, 0.8), nrow = m, ncol = m)
delta <- stat.dist(gamma)
```
The `stat.dist` function computes the stationary distribution.

- Generate data with one of the functions defined in [Generating data](#generating-data)
```{r 6simu-gen-data}
simu_data <- pois.HMM.generate.sample(ns = DATA_SIZE_SIMU,
                                      mod = list(m = m,
                                                 lambda = lambda,
                                                 gamma = gamma,
                                                 delta = delta))$data
```

- Set initial parameters
```{r 6simu-init-params}
# Parameters and covariates
m <- 2
gamma <- matrix(c(0.6, 0.4,
                  0.4, 0.6), nrow = m, ncol = m)
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
# Display Poisson means
lambda
```

- Transform them into working parameters
```{r 6simu-pn2pw}
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = simu_data, m = m)
```

- Estimate the parameters via a function
```{r 6simu-estim}
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
                     DLL = "poi_hmm", silent = TRUE)

# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
                  objective = obj_tmb$fn,
                  gradient = obj_tmb$gr,
                  hessian = obj_tmb$he)

# Check convergence
mod_tmb$convergence == 0

# Results
summary(sdreport(obj_tmb), "report")
```

For the code used to generate coverage probabilities and acceleration results, please take a look at *[code/poi_hmm_simu1.R](code/poi_hmm_simu1.R)* and *[code/poi_hmm_simu2.R](code/poi_hmm_simu2.R)*.

## Lamb data
We detail here the code used to estimate a 2-state Poisson HMM based on the lamb dataset available in INSERT GITHUB LINK

- Set a seed for randomness, and load files
```{r 6lamb-init}
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
load("data/fetal-lamb.RData")
lamb_data <- lamb
rm(lamb)
```

- Set initial parameters
```{r 6lamb-init-params}
# Parameters and covariates
m <- 2
gamma <- matrix(c(0.8, 0.2,
                  0.2, 0.8), nrow = m, ncol = m)
lambda <- seq(0.3, 4, length.out = m)
delta <- stat.dist(gamma)
```

- Transform them into working parameters
```{r 6lamb-pn2pw}
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = lamb_data, m = m)
```

- Estimate the parameters via a function
```{r 6lamb-estim}
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
                     DLL = "poi_hmm", silent = TRUE)

# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
                  objective = obj_tmb$fn,
                  gradient = obj_tmb$gr,
                  hessian = obj_tmb$he)

# Check convergence
mod_tmb$convergence == 0

# Results
summary(sdreport(obj_tmb), "report")
```