# Multivariate Gaussian HMM

Multivariate Gaussian HMMs with TMB are very similar to the previous Poisson HMM.
The main changes are the distribution parameters being changed from $\bs{\lambda}$ to $\bs{\mu}$ and $\bs{\Sigma}$.
In turn, these cause the density function to change from `dpois` to `mvdnorm` (and from `rpois` to `mvrnorm` for simulations).

Many functions available in *[functions/utils.R](#utils.R)* have been adapted for the multivariate Gaussian case in *[functions/mvnorm_utils.R](#mvnorm_utils.R)*.

We detail below an example of a two-state trivariate Gaussian HMM with TMB.

## Dataset
The data is generated with the function below (similarly to the Poisson case)
```{r mvnorm.HMM.generate.sample}
```

## Likelihood function
The Gaussian negative log-likelihood in TMB can be coded as
```{Rcpp 7norm_hmm.cpp, code=readLines("code/norm_hmm.cpp"), eval=FALSE}
```

and requires the following utility functions.
```{Rcpp 7norm_utils.cpp, code=readLines("functions/norm_utils.cpp"), eval=FALSE}
```

## Estimation
```{r 8example}
source("code/packages.R")
source("functions/mvnorm_utils.R")

# TMB::precompile()
TMB::compile("code/mvnorm_hmm.cpp")
dyn.load(TMB::dynlib("code/mvnorm_hmm"))

set.seed(123)

# Two states
m <- 2
# Trivariate Normal distribution
p <- 3

# One row per state, one column per dimension of the data
mu <- matrix(c(6,8,9,
               1,2,3), nrow = m, ncol = p, byrow = TRUE)
# Two covariance matrices
sigma1 <- matrix(c(1.0, 0.5, 0.5,
                   0.5, 1.0, 0.5,
                   0.5, 0.5, 1.0), nrow = p, ncol = p, byrow = TRUE)

sigma2 <- matrix(c(2.0, 1.5, 1.5,
                   1.5, 2.0, 1.5,
                   1.5, 1.5, 2.0), nrow = p, ncol = p, byrow = TRUE)
# We store them in an array for convenience, making them
# easily distinguishable at a glance when displayed
sigma <- array(c(sigma1, sigma2), dim = c(p, p, m))

gamma <- matrix(c(0.95, 0.05,
                  0.15, 0.85), byrow = TRUE, nrow = m, ncol = m)

mod <- list(m = m,
            mu = mu,
            sigma = sigma,
            gamma = gamma)

# Similarly to the Poisson case, we can generate data.
# Here, we generate a trivariate Gaussian sample of size 1000.
TMBdata <- mvnorm.HMM.generate.sample(1000, mod)
# TMB requires a list
TMB_data <- list(x = TMBdata$data,
                 m = m)
# TMB requires the parameters to be either vectors, matrices, or arrays.
# For simplicity, we pass the parameters as a list of vectors and matrices.
pw <- mvnorm.HMM.pn2pw(m = m,
                       mu = mu, sigma = sigma, gamma = gamma)

obj_tmb <- TMB::MakeADFun(data = TMB_data,
                          parameters = pw,
                          DLL = "mvnorm_hmm",
                          silent = TRUE)

res <- nlminb(start = obj_tmb$par,
              objective = obj_tmb$fn,
              gradient = obj_tmb$gr,
              hessian = obj_tmb$he)
```

## Results
```{r 8obj-report}
summary(sdreport(obj_tmb), "report")
# More readable estimates
report <- obj_tmb$report()
report
```

## Residuals
Since the data was simulated, the true parameters are known and the validity of the estimates cam be checked.
```{r 8results-verification}
t(report$mu) - mu
report$sigma - sigma
report$gamma - gamma
```
The parameter estimation was successful
