# Principles of using `TMB` for Maximum Likelihood Estimation

## Setting up `TMB`

- Install [Rtools](https://cran.r-project.org/bin/windows/Rtools/)
- Install the R-package `TMB` [@R-TMB]
- (Optional) Setup error debugging in `RStudio` by running the command `TMB:::setupRstudio()`

Advanced use is detailed in https://kaskr.github.io/adcomp/_book/Tutorial.html

## Getting started with a linear regression

Let $\b{x}$ and $\b{y}$ denote the predictor and response vector, respectively, both of length $n$.
For a simple linear regression model with intercept $a$ and slope $b$, the negative log-likelihood equals
\begin{equation*}
- \log L(a, b, \sigma^2) = - \sum_{i=1}^n \log(\phi(y_i; a + bx_i, \sigma^2))),
\end{equation*}
where $\phi(\cdot; \mu, \sigma^2)$ corresponds to the density function of the univariate normal distribution with mean $\mu$ and variance $\sigma^2$.

The use of `TMB` requires the (negative) log-likelihood function to be coded in C++ under a specific template, which is then loaded into R.
The minimization of this function and other post-processing procedures are all carried out in `R`.
Therefore, we require two files.\
The first file, named [*linreg.cpp*](code/linreg.cpp), is written in C++ and defines the objective function, i.e. the negative log-likelihood (nll) function of the linear model.

```{Rcpp 2linreg.cpp, code=readLines("code/linreg.cpp"), eval=FALSE}
```

The second file needed is written in `R` and serves for compiling the nll function defined above and carrying out the estimation procedure by numerical optimization of the nll function.
The .R file (shown below) carries out the compilation of the C++ file and minimization of the nll function:
```{r 2init-linreg}
# Loading TMB package
library(TMB)
# Compilation. The compiler returns 0 if the compilation of
# the cpp file was successful
TMB::compile("code/linreg.cpp")
# Dynamic loading of the compiled cpp file
dyn.load(dynlib("code/linreg"))
# Generate the data for our test sample
set.seed(123)
data <- list(y = rnorm(20) + 1:20, x = 1:20)
parameters <- list(a = 0, b = 0, tsigma = 0)
# Instruct TMB to create the likelihood function
obj_linreg <- MakeADFun(data, parameters, DLL = "linreg",
                        silent = TRUE)
# Optimization of the objective function with nlminb
mod_linreg <- nlminb(obj_linreg$par, obj_linreg$fn)
mod_linreg$par
```

Now that the optimization is taken care of, we can display the estimates details
```{r sdreport}
sdreport(obj_linreg)
```
or every variable
```{r summary_sdreport}
summary(sdreport(obj_linreg))
```
The `select` argument restricts the output to variables passed
by `ADREPORT(variable_name);` in the [*linreg.cpp*](code/linreg.cpp) file.
As we will see in [Wald-type], this lets us derive confidence intervals for these natural parameters easily.
```{r 2summary_sdreport_report}
summary(sdreport(obj_linreg), select = "report")
```

Lastly, we display the estimates from `lm` to compare them to the ones from `TMB`.
```{r 2lm}
lm(y ~ x, data = data)$coefficients
```

## Extending the `C++` negative log-likelihood

It is noteworthy that `linreg.cpp` doesn't have to contains many lines of code, as they can be distributed in other files and loaded.
Writing extra files to define functions compatible with `TMB` requires some care, as these must follow `TMB`'s template.
For example, we can define this function
```{Rcpp 2utils_linreg.cpp, code=readLines("functions/utils_linreg.cpp"), eval=FALSE}
```
 which doesn't do anything useful and import it in `linreg.cpp`
```{Rcpp 2linreg_utils.cpp, code=readLines("code/linreg_utils.cpp"), eval=FALSE}
```