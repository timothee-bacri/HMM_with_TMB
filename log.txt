function(m, lambda, gamma, delta = NULL, lambda_std_error = NULL, gamma_std_error = NULL, delta_std_error = NULL) {
  # Get the indexes of the sorted states
  # according to ascending lambda
  # sorted_lambda contains the permutations needed
  sorted_lambda <- sort(lambda, index.return = TRUE)$ix
  ordered_lambda <- lambda[sorted_lambda]
  # Re-order the TPM according to the switched states
  # in the sorted lambda
  ordered_gamma <- matrix(0, nrow = m, ncol = m)
  for (col in 1:m) {
    new_col <- which(sorted_lambda == col)
    for (row in 1:m) {
      new_row <- which(sorted_lambda == row)
      ordered_gamma[row, col] <- gamma[new_row, new_col]
    }
  }
  # Same for the TPM's standard errors
  ordered_gamma_std_error <- NULL
  if (!is.null(gamma_std_error)) {
    ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
    for (col in 1:m) {
      new_col <- which(sorted_lambda == col)
      for (row in 1:m) {
        new_row <- which(sorted_lambda == row)
        ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
      }
    }
  }
  
  # Re-order the stationary distribution if it is provided
  # Generate it otherwise
  if (is.null(delta)) {
    ordered_delta <- stat.dist(ordered_gamma)
  } else {
    ordered_delta <- delta[sorted_lambda]
  }
  # Re-order the standard errors
  ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
  ordered_delta_std_error <- delta_std_error[sorted_lambda]
  
  result <- list(lambda = ordered_lambda,
                 gamma = ordered_gamma,
                 delta = ordered_delta,
                 lambda_std_error = ordered_lambda_std_error,
                 gamma_std_error = ordered_gamma_std_error,
                 delta_std_error = ordered_delta_std_error)
  
  # Remove the NULL elements
  result[sapply(result, is.null)] <- NULL
  
  return(result)
}
function(m, lambda, gamma, delta = NULL, lambda_std_error = NULL, gamma_std_error = NULL, delta_std_error = NULL) {
  # Get the indexes of the sorted states
  # according to ascending lambda
  # sorted_lambda contains the permutations needed
  sorted_lambda <- sort(lambda, index.return = TRUE)$ix
  ordered_lambda <- lambda[sorted_lambda]
  # Re-order the TPM according to the switched states
  # in the sorted lambda
  ordered_gamma <- matrix(0, nrow = m, ncol = m)
  for (col in 1:m) {
    new_col <- which(sorted_lambda == col)
    for (row in 1:m) {
      new_row <- which(sorted_lambda == row)
      ordered_gamma[row, col] <- gamma[new_row, new_col]
    }
  }
  # Same for the TPM's standard errors
  ordered_gamma_std_error <- NULL
  if (!is.null(gamma_std_error)) {
    ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
    for (col in 1:m) {
      new_col <- which(sorted_lambda == col)
      for (row in 1:m) {
        new_row <- which(sorted_lambda == row)
        ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
      }
    }
  }
  
  # Re-order the stationary distribution if it is provided
  # Generate it otherwise
  if (is.null(delta)) {
    ordered_delta <- stat.dist(ordered_gamma)
  } else {
    ordered_delta <- delta[sorted_lambda]
  }
  # Re-order the standard errors
  ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
  ordered_delta_std_error <- delta_std_error[sorted_lambda]
  
  result <- list(lambda = ordered_lambda,
                 gamma = ordered_gamma,
                 delta = ordered_delta,
                 lambda_std_error = ordered_lambda_std_error,
                 gamma_std_error = ordered_gamma_std_error,
                 delta_std_error = ordered_delta_std_error)
  
  # Remove the NULL elements
  result[sapply(result, is.null)] <- NULL
  
  return(result)
}
function(m, lambda, gamma, delta = NULL, lambda_std_error = NULL, gamma_std_error = NULL, delta_std_error = NULL) {
  # Get the indexes of the sorted states
  # according to ascending lambda
  # sorted_lambda contains the permutations needed
  sorted_lambda <- sort(lambda, index.return = TRUE)$ix
  ordered_lambda <- lambda[sorted_lambda]
  # Re-order the TPM according to the switched states
  # in the sorted lambda
  ordered_gamma <- matrix(0, nrow = m, ncol = m)
  for (col in 1:m) {
    new_col <- which(sorted_lambda == col)
    for (row in 1:m) {
      new_row <- which(sorted_lambda == row)
      ordered_gamma[row, col] <- gamma[new_row, new_col]
    }
  }
  # Same for the TPM's standard errors
  ordered_gamma_std_error <- NULL
  if (!is.null(gamma_std_error)) {
    ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
    for (col in 1:m) {
      new_col <- which(sorted_lambda == col)
      for (row in 1:m) {
        new_row <- which(sorted_lambda == row)
        ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
      }
    }
  }
  
  # Re-order the stationary distribution if it is provided
  # Generate it otherwise
  if (is.null(delta)) {
    ordered_delta <- stat.dist(ordered_gamma)
  } else {
    ordered_delta <- delta[sorted_lambda]
  }
  # Re-order the standard errors
  ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
  ordered_delta_std_error <- delta_std_error[sorted_lambda]
  
  result <- list(lambda = ordered_lambda,
                 gamma = ordered_gamma,
                 delta = ordered_delta,
                 lambda_std_error = ordered_lambda_std_error,
                 gamma_std_error = ordered_gamma_std_error,
                 delta_std_error = ordered_delta_std_error)
  
  # Remove the NULL elements
  result[sapply(result, is.null)] <- NULL
  
  return(result)
}
$lambda
[1] 10 20 30

$gamma
     [,1] [,2] [,3]
[1,]   33   31   32
[2,]   13   11   12
[3,]   23   21   22

$delta
[1] -0.032786885  0.016393443 -0.008196721

