# We want to store the next 5 values without using rbind
# If the file is rerun, this variable won't store new results on top of the
# old ones
indices <- (1 + 5 * (idx - 1)):(5 + 5 * (idx - 1))
mllk_values_lamb[indices, ] <- cbind(m = rep(m, 5),
procedure = PROCEDURES,
mllk = c(dm$mllk,
tmb$mllk,
tmb_g$mllk,
tmb_h$mllk,
tmb_gh$mllk),
AIC = c(dm$AIC,
tmb$AIC,
tmb_g$AIC,
tmb_h$AIC,
tmb_gh$AIC),
BIC = c(dm$BIC,
tmb$BIC,
tmb_g$BIC,
tmb_h$BIC,
tmb_gh$BIC))
# Creating variables for the CIs -----------------
tmb_CI <- tmb_gh
params_names_latex <- paste0(rep("$\\lambda_{", m), 1:m, "}$")
for (gamma_idx in 1:m ^ 2) {
# Get row and column indices for gamma instead of the default
# columnwise index: the default indices are 1:m for the 1st column,
# then (m + 1):(2 * m) for the 2nd, etc...
row_col_idx <- matrix.col.idx.to.rowcol(gamma_idx, m)
params_names_latex <- c(params_names_latex,
paste0("$\\gamma_{", paste0(row_col_idx, collapse = ""), "}$"))
}
params_names_latex <- c(params_names_latex,
paste0(rep("$\\delta_{", m), 1:m, "}$"))
len_par <- length(params_names_latex)
indices <- (length(conf_int_lamb$m) + 1):(length(conf_int_lamb$m) + len_par)
conf_int_lamb[indices, "m"] <- m
conf_int_lamb[indices, "Parameter"] <- params_names_latex
# Reminder, PARAMS_NAMES contains c("lambda", "gamma", "delta")
conf_int_lamb[indices, "Estimate"] <- unlist(tmb_CI[PARAMS_NAMES])
param_tmb_CI <- pois.HMM.pn2pw(m = m, lambda = tmb_CI$lambda, gamma = tmb_CI$gamma)
if (m == 1) {
w_params_names <- c("tlambda1")
} else {
w_params_names <- c(paste0(rep("tlambda", m), 1:m),
paste0(rep("tgamma", m ^ 2 - m), 1:(m ^ 2 - m)))
}
len_w_par <- length(w_params_names)
working_conf_int <- data.frame(w_parameter = w_params_names,
lower = rep(NA, len_w_par),
upper = rep(NA, len_w_par),
stringsAsFactors = FALSE)
lambda_indices <- 1:m
gamma_indices <- m + 1:(m ^ 2)
delta_indices <- m ^ 2 + m + (1:m)
tgamma_indices <- (m + 1):(m ^ 2)
idx=1
set.seed(1)
# Parameters and covariates --------------------------
m <- M_LIST_LAMB[idx]
if (m == 1) {
gamma_init <- matrix(1)
} else {
gamma_init <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma_init) <- 0.8
}
lambda_init <- seq(0.3, 4, length.out = m)
delta_init <- stat.dist(gamma_init)
# Parameters & covariates for TMB ------------------
working_params_init <- pois.HMM.pn2pw(m, lambda_init, gamma_init)
TMB_data <- list(x = lamb_data, m = m)
obj_init <- MakeADFun(TMB_data, working_params_init, DLL = "poi_hmm", silent = TRUE)
parvect_init <- pois.HMM.pn2pw(m = m, lambda = lambda_init, gamma = gamma_init, delta = delta_init)
parvect_init <- unlist(parvect_init)
# Estimation ------------------------------------
dm <- DM.estimate(x = lamb_data,
m = m,
lambda0 = lambda_init,
gamma0 = gamma_init)
tmb <- TMB.estimate(TMB_data = TMB_data,
parameters = working_params_init,
MakeADFun_obj = obj_init)
tmb_g <- TMB.estimate(TMB_data = TMB_data,
parameters = working_params_init,
MakeADFun_obj = obj_init,
gradient = TRUE)
tmb_h <- TMB.estimate(TMB_data = TMB_data,
parameters = working_params_init,
MakeADFun_obj = obj_init,
hessian = TRUE)
tmb_gh <- TMB.estimate(TMB_data = TMB_data,
parameters = working_params_init,
MakeADFun_obj = obj_init,
gradient = TRUE,
hessian = TRUE,
std_error = TRUE)
# If one doesn't converge successfully, stop
if (dm$convergence != 0) {
stop(paste("dm didn't converge properly, lamb dataset, m =", m))
}
if (tmb$convergence != 0) {
stop(paste("tmb didn't converge properly, lamb dataset, m =", m))
}
if (tmb_g$convergence != 0) {
stop(paste("tmb_g didn't converge properly, lamb dataset, m =", m))
}
if (tmb_h$convergence != 0) {
stop(paste("tmb_h didn't converge properly, lamb dataset, m =", m))
}
if (tmb_gh$convergence != 0) {
stop(paste("tmb_gh didn't converge properly, lamb dataset, m =", m))
}
# Store negative log-likelihoods --------------------------------------------
# We want to store the next 5 values without using rbind
# If the file is rerun, this variable won't store new results on top of the
# old ones
indices <- (1 + 5 * (idx - 1)):(5 + 5 * (idx - 1))
mllk_values_lamb[indices, ] <- cbind(m = rep(m, 5),
procedure = PROCEDURES,
mllk = c(dm$mllk,
tmb$mllk,
tmb_g$mllk,
tmb_h$mllk,
tmb_gh$mllk),
AIC = c(dm$AIC,
tmb$AIC,
tmb_g$AIC,
tmb_h$AIC,
tmb_gh$AIC),
BIC = c(dm$BIC,
tmb$BIC,
tmb_g$BIC,
tmb_h$BIC,
tmb_gh$BIC))
# Creating variables for the CIs -----------------
tmb_CI <- tmb_gh
params_names_latex <- paste0(rep("$\\lambda_{", m), 1:m, "}$")
for (gamma_idx in 1:m ^ 2) {
# Get row and column indices for gamma instead of the default
# columnwise index: the default indices are 1:m for the 1st column,
# then (m + 1):(2 * m) for the 2nd, etc...
row_col_idx <- matrix.col.idx.to.rowcol(gamma_idx, m)
params_names_latex <- c(params_names_latex,
paste0("$\\gamma_{", paste0(row_col_idx, collapse = ""), "}$"))
}
params_names_latex <- c(params_names_latex,
paste0(rep("$\\delta_{", m), 1:m, "}$"))
len_par <- length(params_names_latex)
indices <- (length(conf_int_lamb$m) + 1):(length(conf_int_lamb$m) + len_par)
conf_int_lamb[indices, "m"] <- m
conf_int_lamb[indices, "Parameter"] <- params_names_latex
# Reminder, PARAMS_NAMES contains c("lambda", "gamma", "delta")
conf_int_lamb[indices, "Estimate"] <- unlist(tmb_CI[PARAMS_NAMES])
param_tmb_CI <- pois.HMM.pn2pw(m = m, lambda = tmb_CI$lambda, gamma = tmb_CI$gamma)
if (m == 1) {
w_params_names <- c("tlambda1")
} else {
w_params_names <- c(paste0(rep("tlambda", m), 1:m),
paste0(rep("tgamma", m ^ 2 - m), 1:(m ^ 2 - m)))
}
len_w_par <- length(w_params_names)
working_conf_int <- data.frame(w_parameter = w_params_names,
lower = rep(NA, len_w_par),
upper = rep(NA, len_w_par),
stringsAsFactors = FALSE)
lambda_indices <- 1:m
gamma_indices <- m + 1:(m ^ 2)
delta_indices <- m ^ 2 + m + (1:m)
tgamma_indices <- (m + 1):(m ^ 2)
# Benchmarks ------------
set.seed(2)
rnorm(1)
# Benchmarks ------------
set.seed(2)
benchmark_model <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE_LAMB,
mod = list(m = m,
lambda = tmb_CI$lambda,
gamma = tmb_CI$gamma,
delta = tmb_CI$delta),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init,
delta = delta_init),
test_marqLevAlg = TRUE)
rnorm(1)
set.seed(2)
rnorm(1)
set.seed(2)
microbenchmark("BFGS" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "BFGS", control = ctrl)$convergence==0,
"L-BFGS-B" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "L-BFGS-B", control = ctrl)$convergence==0,
"nlm" = nlm(f = nlmfn, p = obj_benchmark$par, obj_benchmark, iterlim = 10000)$code==1,
"nlminb" = nlminb(start = obj_benchmark$par, objective = obj_benchmark$fn, gradient = obj_benchmark$gr, hessian = obj_benchmark$he)$convergence==0,
"hjn" = hjn(par = obj_benchmark$par, fn = obj_benchmark$fn)$convergence==0,
"marqLevAlg" = marqLevAlg(b = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, hess = obj_benchmark$he, maxiter = 10000)$istop==1,
times = 1,
check = "equal",
setup = obj_benchmark <<- MakeADFun(TMB_benchmark_data, working_params_init, DLL = "poi_hmm", silent = TRUE))
benchmark_data <- benchmark_model$data
TMB_benchmark_data <- list(x = benchmark_data, m = m)
obj_benchmark <- MakeADFun(TMB_benchmark_data, working_params_init, DLL = "poi_hmm", silent = TRUE)
parvect_benchmark <- pois.HMM.pn2pw(m = m, lambda = lambda_init, gamma = gamma_init, delta = delta_init)
# nlminb needs a vector, not a list
parvect_benchmark <- unlist(parvect_benchmark)
set.seed(2)
microbenchmark("BFGS" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "BFGS", control = ctrl)$convergence==0,
"L-BFGS-B" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "L-BFGS-B", control = ctrl)$convergence==0,
"nlm" = nlm(f = nlmfn, p = obj_benchmark$par, obj_benchmark, iterlim = 10000)$code==1,
"nlminb" = nlminb(start = obj_benchmark$par, objective = obj_benchmark$fn, gradient = obj_benchmark$gr, hessian = obj_benchmark$he)$convergence==0,
"hjn" = hjn(par = obj_benchmark$par, fn = obj_benchmark$fn)$convergence==0,
"marqLevAlg" = marqLevAlg(b = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, hess = obj_benchmark$he, maxiter = 10000)$istop==1,
times = 1,
check = "equal",
setup = obj_benchmark <<- MakeADFun(TMB_benchmark_data, working_params_init, DLL = "poi_hmm", silent = TRUE)
rnorm(1)
set.seed(2)
benchmark_model <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE_LAMB,
mod = list(m = m,
lambda = tmb_CI$lambda,
gamma = tmb_CI$gamma,
delta = tmb_CI$delta),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init,
delta = delta_init),
test_marqLevAlg = TRUE)
# Benchmarks ------------
set.seed(2)
rnorm(1)
set.seed(2)
microbenchmark("BFGS" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "BFGS", control = ctrl)$convergence==0,
"L-BFGS-B" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "L-BFGS-B", control = ctrl)$convergence==0,
"nlm" = nlm(f = nlmfn, p = obj_benchmark$par, obj_benchmark, iterlim = 10000)$code==1,
"nlminb" = nlminb(start = obj_benchmark$par, objective = obj_benchmark$fn, gradient = obj_benchmark$gr, hessian = obj_benchmark$he)$convergence==0,
"hjn" = hjn(par = obj_benchmark$par, fn = obj_benchmark$fn)$convergence==0,
"marqLevAlg" = marqLevAlg(b = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, hess = obj_benchmark$he, maxiter = 10000)$istop==1,
times = 1,
check = "equal",
setup = obj_benchmark <<- MakeADFun(TMB_benchmark_data, working_params_init, DLL = "poi_hmm", silent = TRUE))
rnorm(1)
set.seed(2)
MakeADFun(TMB_benchmark_data, working_params_init, DLL = "poi_hmm", silent = TRUE)
rnorm(1)
set.seed(2)
marqLevAlg(b = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, hess = obj_benchmark$he, maxiter = 10000)$istop==1
rnorm(1)
set.seed(2)
hjn(par = obj_benchmark$par, fn = obj_benchmark$fn)$convergence==0
rnorm(1)
set.seed(2)
nlminb(start = obj_benchmark$par, objective = obj_benchmark$fn, gradient = obj_benchmark$gr, hessian = obj_benchmark$he)$convergence==0
rnorm(1)
set.seed(2)
nlm(f = nlmfn, p = obj_benchmark$par, obj_benchmark, iterlim = 10000)$code==1
rnorm(1)
set.seed(2)
optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "L-BFGS-B", control = ctrl)$convergence==0
rnorm(1)
set.seed(2)
optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "BFGS", control = ctrl)$convergence==0
rnorm(1)
set.seed(2)
rnorm(1)
set.seed(2)
microbenchmark("BFGS" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "BFGS", control = ctrl)$convergence==0,
"L-BFGS-B" = optim(par = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, method = "L-BFGS-B", control = ctrl)$convergence==0,
"nlm" = nlm(f = nlmfn, p = obj_benchmark$par, obj_benchmark, iterlim = 10000)$code==1,
"nlminb" = nlminb(start = obj_benchmark$par, objective = obj_benchmark$fn, gradient = obj_benchmark$gr, hessian = obj_benchmark$he)$convergence==0,
"hjn" = hjn(par = obj_benchmark$par, fn = obj_benchmark$fn)$convergence==0,
"marqLevAlg" = marqLevAlg(b = obj_benchmark$par, fn = obj_benchmark$fn, gr = obj_benchmark$gr, hess = obj_benchmark$he, maxiter = 10000)$istop==1,
times = 1,
check = "equal",
setup = obj_benchmark <<- MakeADFun(TMB_benchmark_data, working_params_init, DLL = "poi_hmm", silent = TRUE))
rnorm(1)
set.seed(2)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
rnorm(1)
set.seed(2)
microbenchmark("1" = TRUE, "2" = TRUE)
rnorm(1)
set.seed(2)
microbenchmark("1" = TRUE, "2" = TRUE, control = list("order"="inorder"))
rnorm(1)
method_comparison_df_simu1
RUN_TINNITUS
source("code/setup_parameters.R")
load("data/results_lamb.RData")
load("data/results_simu1.RData")
method_comparison_df_lamb
mean(method_comparison_df_lamb$time[method_comparison_df_lamb$procedure="BFGS"])
mean(method_comparison_df_lamb$time[method_comparison_df_lamb$procedure=="BFGS"])
mean(method_comparison_df_lamb$time[method_comparison_df_lamb$procedure=="L-BFGS-B"])
mean(method_comparison_df_lamb$time[method_comparison_df_lamb$procedure=="marqLevAlg"])
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/setup_parameters.R', echo=TRUE)
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/main.R', echo=TRUE)
sms("FINI")
tinntime
warnings()
coverage_skips_simu1
coverage_skips_lamb
coverage_skips_simu2
coverage_skips_tinn
conf_int_tinn
conf_int_simu2
conf_int_simu1
conf_int_lamb
print(conf_int_lamb$Coverage.Bootstrap, digits = 5)
knitr::knit2pdf("paper.rnw")
knitr::knit2pdf("paper.rnw")
knitr::knit2pdf("paper.rnw")
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/main.R', echo=TRUE)
sink()
sink()
install.packages(c("dplyr", "openxlsx", "rio", "stringi", "testthat", "xfun"))
source("code/setup_parameters.R")
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/setup_parameters.R', echo=TRUE)
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/main.R', echo=TRUE)
sms("FINI")
clear
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
stopImplicitCluster()
install.packages(c("broom", "colorspace", "curl", "dplyr", "gert", "lme4", "mime", "stringi"))
sink(
)
sink("log.txt") # Redirect all messages from the console to log.txt
source("code/setup_parameters.R")
if (RUN_SIMULATION2) {
source("code/poi_hmm_simu2.R")
save(M_LIST_SIMU2, estim_benchmarks_df_simu2, method_comparison_df_simu2, coverage_skips_simu2,
mllk_values_simu2, mllk_times_df_simu2, conf_int_simu2,
file = "data/results_simu2.RData")
} else {
load("data/results_simu2.RData")
}
simu2time <- Sys.time()
sms(paste("simu2 ", round(simu2time - simu1time, 1), units(simu2time - simu1time)))
# print(simu2time - lambtime)
## ---- Hospital
# if (RUN_HOSPITAL) {
#   source("code/poi_hmm_hosp.R")
#   save(M_LIST_HOSP, estim_benchmarks_df_hosp, method_comparison_df_hosp,
#        mllk_values_hosp, mllk_times_df_hosp, conf_int_hosp,
#        file = "data/results_hosp.RData")
# } else {
#   load("data/results_hosp.RData")
# }
# hosptime <- Sys.time()
# print(hosptime - simutime)
## ---- Tinnitus
if (RUN_TINNITUS) {
source("code/poi_hmm_tinn.R")
save(M_LIST_TINN, estim_benchmarks_df_tinn, method_comparison_df_tinn, coverage_skips_tinn,
mllk_values_tinn, mllk_times_df_tinn, conf_int_tinn, consistency_estim_benchmarks_df_tinn,
file = "data/results_tinn.RData")
} else {
load("data/results_tinn.RData")
}
tinntime <- Sys.time()
sms(paste("tinn ", round(tinntime - simu2time, 1), units(tinntime - simu2time)))
# print(tinntime - hosptime)
# for(a in 1:3){
#   i=0
#   message(paste0("a=",a))
#   repeat{
#     message(i)
#     i=i+1
#     if(i!=7){
#       next
#     }
#     break
#   }
#   message("out of inner loop")
# }
sink() # Stop the log redirection
sink("log.txt") # Redirect all messages from the console to log.txt
source("code/setup_parameters.R")
# options("warn")
# options(warn = 2)
# options(warn = 0) # DEFAULT
# knitr::knit2pdf("paper.rnw")
# Which dataset are tests run on
RUN_LAMB <- TRUE
RUN_SIMULATION1 <- TRUE
RUN_SIMULATION2 <- TRUE
# RUN_HOSPITAL <- FALSE
RUN_TINNITUS <- TRUE
sink()
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/main.R', echo=TRUE)
lambtime
lambtime
sink()
sink()
lambtime
paste("simu1 ", round(simu1time - lambtime, 1), units(simu1time - lambtime))
simu1time - lambtime
lambtime
begin
lambtime - begin
sms(paste("lamb ", round(lambtime - begin, 1), units(lambtime - begin)))
httr_options("get")
httr_options("get")
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/functions/utils_personal.R', encoding = 'UTF-8', echo=TRUE)
sms(paste("lamb ", round(lambtime - begin, 1), units(lambtime - begin)))
config("insecure")
config(ssl_verifypeer = 0L, ssl_verifyhost = 0L)
class(config(ssl_verifypeer = 0L, ssl_verifyhost = 0L))
sms <- function(msg) {
txt <- URLencode(msg)
url <- 'https://smsapi.free-mobile.fr/sendmsg?user=10077537&pass=J81OVEn1ZR1vne&msg='
txt <- paste0(url, txt)
tryCatch({
code <- GET(txt, config = config(ssl_verifypeer = 0L, ssl_verifyhost = 0L))
},
error = function (e){
print(e)
tryCatch({
library(xml2)
code <- read_html(txt)
},
error = function(e){
print(e)
code <- readLines(txt)
},
warning = function(w){
print(w)
})
},
warning = function(w){
print(w)
})
sms_result <- switch(toString(code$status_code),
"200" = "Le SMS a été envoyé sur votre mobile",
"400" = "Un des paramètres obligatoires est manquant",
"402" = "Trop de SMS ont été envoyés en trop peu de temps",
"403" = "Le service n'est pas activé sur l'espace abonné, ou login / clé incorrect",
"500" = "Erreur coté serveur, Veuillez réessayer ultérieurement")
return(sms_result)
}
sms(paste("lamb ", round(lambtime - begin, 1), units(lambtime - begin)))
sms <- function(msg) {
txt <- URLencode(msg)
url <- 'https://smsapi.free-mobile.fr/sendmsg?user=10077537&pass=J81OVEn1ZR1vne&msg='
txt <- paste0(url, txt)
tryCatch({
code <- GET(txt, config = config(ssl_verifypeer = 0L, ssl_verifyhost = 0L))
},
error = function (e){
print(e)
tryCatch({
library(xml2)
code <- read_html(txt)
},
error = function(e){
print(e)
code <- readLines(txt)
},
warning = function(w){
print(w)
})
},
warning = function(w){
print(w)
})
sms_result <- switch(toString(code$status_code),
"200" = "Le SMS a été envoyé sur votre mobile",
"400" = "Un des paramètres obligatoires est manquant",
"402" = "Trop de SMS ont été envoyés en trop peu de temps",
"403" = "Le service n'est pas activé sur l'espace abonné, ou login / clé incorrect",
"500" = "Erreur coté serveur, Veuillez réessayer ultérieurement")
return(sms_result)
}
sms("a")
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/setup_parameters.R', echo=TRUE)
sms("a")
source('C:/Users/riw011/Dropbox/TMB_HMM/paper1/code/main.R', echo=TRUE)
tinntime
tinntime - simu2time
sms(paste("tinn ", round(tinntime - simu2time, 1), units(tinntime - simu2time)))
M_LIST_SIMU2
estim_benchmarks_df_simu2
method_comparison_df_simu2
coverage_skips_simu2
mllk_values_simu2
mllk_times_df_simu2
conf_int_simu2
save(M_LIST_SIMU2, estim_benchmarks_df_simu2, method_comparison_df_simu2, coverage_skips_simu2,
mllk_values_simu2, mllk_times_df_simu2, conf_int_simu2,
file = "data/results_simu2.RData")
estim_benchmarks_df_tinn
method_comparison_df_tinn
coverage_skips_tinn
consistency_estim_benchmarks_df_tinn
coverage_skips_tinn
conf_int_tinn
mllk_times_df_tinn
mllk_values_tinn
M_LIST_TINN
save(M_LIST_TINN, estim_benchmarks_df_tinn, method_comparison_df_tinn, coverage_skips_tinn,
mllk_values_tinn, mllk_times_df_tinn, conf_int_tinn, consistency_estim_benchmarks_df_tinn,
file = "data/results_tinn.RData")
knitr::knit2pdf("paper.rnw")
