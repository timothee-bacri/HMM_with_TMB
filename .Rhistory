lambda <- c(1, 3, 5)
gamma <- matrix(c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda, gamma)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 5, 6, 7, 6, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
summary(sdreport(fixed_par_obj_tmb), "report")
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 4, 5, 6, 7, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
summary(sdreport(fixed_par_obj_tmb), "report")
as.factor(c(4, 4, 5, 6, 7, 8))
parameters
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 4, 5, 6, 7, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
summary(sdreport(fixed_par_obj_tmb), "report")
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 9, 5, 6, 7, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
summary(sdreport(fixed_par_obj_tmb), "report")
# summary(sdreport(fixed_par_obj_tmb), "report")
a <- summary(sdreport(fixed_par_obj_tmb), "report")
a
rownames(a)
a[rownames(a)=="gamma",]
a[rownames(a)=="gamma","Estimate"]
matrix(a[rownames(a)=="gamma","Estimate"], nrow = 2, ncol = 2, byrow = TRUE)
matrix(a[rownames(a)=="gamma","Estimate"], nrow = 3, ncol = 3, byrow = TRUE)
b <- matrix(a[rownames(a)=="gamma","Estimate"], nrow = 3, ncol = 3, byrow = TRUE)
rowsum(b)
rowSums(b)
b <- matrix(a[rownames(a)=="gamma","Estimate"], nrow = 3, ncol = 3, byrow = FALSE)
rowSums(b)
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 9, 5, 6, 7, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
# summary(sdreport(fixed_par_obj_tmb), "report")
a <- summary(sdreport(fixed_par_obj_tmb), "report")
b <- matrix(a[rownames(a)=="gamma","Estimate"], nrow = 3, ncol = 3, byrow = FALSE)
b
# rowSums(b)
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 4, 5, 6, 7, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
# summary(sdreport(fixed_par_obj_tmb), "report")
a <- summary(sdreport(fixed_par_obj_tmb), "report")
b <- matrix(a[rownames(a)=="gamma","Estimate"], nrow = 3, ncol = 3, byrow = FALSE)
b
# rowSums(b)
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 5, 6, 7, 6, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
# summary(sdreport(fixed_par_obj_tmb), "report")
a <- summary(sdreport(fixed_par_obj_tmb), "report")
b <- matrix(a[rownames(a)=="gamma","Estimate"], nrow = 3, ncol = 3, byrow = FALSE)
b
# rowSums(b)
b[1,2] - b[1,3]
tpm[1,2] - tpm[1,3] == 0
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 5, 6, 7, 6, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
results <- summary(sdreport(fixed_par_obj_tmb), "report")
tpm <- matrix(results[rownames(results)=="gamma","Estimate"], nrow = m, ncol = m, byrow = FALSE)
tpm
tpm[1,2] - tpm[1,3] == 0
# rowSums(b)
library(TMB)
library(optimr)
# Run the C++ file containing the TMB code
TMB::compile("code/poi_hmm.cpp")
# Load it
dyn.load(dynlib("code/poi_hmm"))
# Load the parameter transformation function
source("functions/utils.R")
load("data/tinnitus.RData")
library(xtable)
temp <- paste(tinn_data, collapse = " ")
temp <- as.data.frame(temp)
temp <- xtable(temp,
# align = "lp{15cm}",
caption = "Tinnitus data")
# label = "table:tinnitus_data")
print(temp, include.rownames = FALSE, include.colnames = FALSE,
# hline.after = c(0, nrow(temp)),
type = "html",
html.table.attributes=list("border='0' cellpadding='5' "))
# Model with 2 states
m <- 2
TMB_data <- list(x = tinn_data, m = m)
# Initial set of parameters
lambda <- c(2, 4)
gamma <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda, gamma)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
# Get the previous values, and fix some
fixed_par_lambda <- lambda
fixed_par_lambda[1] <- 1
# Transform them into working parameters
new_parameters <- pois.HMM.pn2pw(m = m,
lambda = fixed_par_lambda,
gamma = gamma)
map <- list(tlambda = as.factor(c(NA, 1)),
tgamma = as.factor(c(2, 3)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, new_parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
summary(sdreport(fixed_par_obj_tmb), "report")
map <- list(tlambda = as.factor(c(1, 2)),
tgamma = as.factor(c(3, 3)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
# Results + check that the constraint is respected
results <- summary(sdreport(fixed_par_obj_tmb), "report")
tpm <- matrix(results[rownames(results) == "gamma", "Estimate"],
nrow = m,
ncol = m,
byrow = FALSE) # Transformations are column-wise by default, be careful!
tpm
tpm[1,2] - tpm[1,3] == 0
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 5, 6, 7, 6, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
map
parameters
library(TMB)
library(optimr)
# Run the C++ file containing the TMB code
TMB::compile("code/poi_hmm.cpp")
# Load it
dyn.load(dynlib("code/poi_hmm"))
# Load the parameter transformation function
source("functions/utils.R")
load("data/tinnitus.RData")
library(xtable)
temp <- paste(tinn_data, collapse = " ")
temp <- as.data.frame(temp)
temp <- xtable(temp,
# align = "lp{15cm}",
caption = "Tinnitus data")
# label = "table:tinnitus_data")
print(temp, include.rownames = FALSE, include.colnames = FALSE,
# hline.after = c(0, nrow(temp)),
type = "html",
html.table.attributes=list("border='0' cellpadding='5' "))
# Model with 2 states
m <- 2
TMB_data <- list(x = tinn_data, m = m)
# Initial set of parameters
lambda <- c(2, 4)
gamma <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda, gamma)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
# Get the previous values, and fix some
fixed_par_lambda <- lambda
fixed_par_lambda[1] <- 1
# Transform them into working parameters
new_parameters <- pois.HMM.pn2pw(m = m,
lambda = fixed_par_lambda,
gamma = gamma)
map <- list(tlambda = as.factor(c(NA, 1)),
tgamma = as.factor(c(2, 3)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, new_parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
summary(sdreport(fixed_par_obj_tmb), "report")
map <- list(tlambda = as.factor(c(1, 2)),
tgamma = as.factor(c(3, 3)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
# Results + check that the constraint is respected
results <- summary(sdreport(fixed_par_obj_tmb), "report")
tpm <- matrix(results[rownames(results) == "gamma", "Estimate"],
nrow = m,
ncol = m,
byrow = FALSE) # Transformations are column-wise by default, be careful!
tpm
tpm[1,2] - tpm[1,3] == 0
map <- list(tlambda = as.factor(c(1, 2, 3)),
tgamma = as.factor(c(4, 5, 6, 7, 6, 8)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
lambda
map <- list(tlambda = as.factor(c(1, 2)),
tgamma = as.factor(c(3, 3)))
fixed_par_obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm",
silent = TRUE,
map = map)
fixed_par_mod_tmb <- nlminb(start = fixed_par_obj_tmb$par,
objective = fixed_par_obj_tmb$fn,
gradient = fixed_par_obj_tmb$gr,
hessian = fixed_par_obj_tmb$he)
# Results + check that the constraint is respected
results <- summary(sdreport(fixed_par_obj_tmb), "report")
tpm <- matrix(results[rownames(results) == "gamma", "Estimate"],
nrow = m,
ncol = m,
byrow = FALSE) # Transformations are column-wise by default, be careful!
tpm
library(TMB)
library(optimr)
# Run the C++ file containing the TMB code
TMB::compile("code/poi_hmm.cpp")
# Load it
dyn.load(dynlib("code/poi_hmm"))
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
getwd()
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
library(TMB)
library(optimr)
# Run the C++ file containing the TMB code
TMB::compile("code/poi_hmm.cpp")
# Load it
dyn.load(dynlib("code/poi_hmm"))
# Load the parameter transformation function
source("functions/utils.R")
load("data/tinnitus.RData")
library(xtable)
temp <- paste(tinn_data, collapse = " ")
temp <- as.data.frame(temp)
temp <- xtable(temp,
# align = "lp{15cm}",
caption = "Tinnitus data")
# label = "table:tinnitus_data")
print(temp, include.rownames = FALSE, include.colnames = FALSE,
# hline.after = c(0, nrow(temp)),
type = "html",
html.table.attributes=list("border='0' cellpadding='5' "))
# Load TMB and optimization packages
library(TMB)
library(optimr)
# Run the {\tt{C++}} file containing the TMB code
TMB::compile("code/poi_hmm.cpp")
# Load it
dyn.load(dynlib("code/poi_hmm"))
# Load the parameter transformation function
source("functions/utils.R")
load("data/tinnitus.RData")
temp <- paste(tinn_data, collapse = " ")
temp <- as.data.frame(temp)
temp <- xtable(temp,
align = "lp{15cm}",
caption = "TYT data. Observations collected by the TYT app on 87 successive days (from left to right). More details on this data set are provided in \\autoref{sec:tyt_data}.",
label = "table:tinnitus_data")
print(temp, include.rownames = FALSE, include.colnames = FALSE,
hline.after = c(0, nrow(temp)))
# Model with 2 states
m <- 2
TMB_data <- list(x = tinn_data, m = m)
# Generate initial set of parameters for optimization
lambda <- c(1, 3)
gamma <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda, gamma)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda, gamma)
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
obj_tmb$par
obj_tmb$fn(obj_tmb$par)
obj_tmb$gr(obj_tmb$par)
obj_tmb$he(obj_tmb$par)
mod_tmb <- nlminb(start = obj_tmb$par, objective = obj_tmb$fn)
# Check that it converged successfully
mod_tmb$convergence == 0
summary(sdreport(obj_tmb, par.fixed = mod_tmb$par), "report")
mod_tmb$objective
# The negative log-likelihood is accessed by the objective
# attribute of the optimized object
mod_tmb <- nlminb(start = obj_tmb$par, objective = obj_tmb$fn,
gradient = obj_tmb$gr, hessian = obj_tmb$he)
mod_tmb$objective
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
m <- 2
load("data/tinnitus.RData")
TMB_data <- list(x = tinn_data, m = m)
# Initial set of parameters
lambda_init <- c(1, 3)
gamma_init <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda_init, gamma_init)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# MLE
ML_working_estimates <- obj_tmb$env$last.par.best
ML_natural_estimates <- obj_tmb$report(ML_working_estimates)
lambda <- ML_natural_estimates$lambda
gamma <- ML_natural_estimates$gamma
delta <- ML_natural_estimates$delta
obj_tmb$env$last.par.best
mod_tmb$par
mod_tmb$par
obj_tmb$env$last.par.best
??TMB::tmbprofile
profile <- tmbprofile(obj = obj_tmb,
name = 2,
trace = FALSE)
head(profile)
profile
confint(profile)
profile3 <- tmbprofile(obj = obj_tmb,
name = 3,
trace = FALSE)
profile4 <- tmbprofile(obj = obj_tmb,
name = 4,
trace = FALSE)
tgamma3_confint <- confint(profile3)
tgamma4_confint <- confint(profile4)
tgamma3_confint
tgamma4_confint
tgamma3_confint <- confint(profile3)
tgamma4_confint <- confint(profile4)
tgamma3_confint
tgamma4_confint
Gamma_w2n
m
tgamma3_confint
profile3 <- tmbprofile(obj = obj_tmb,
name = 3,
trace = FALSE)
tgamma3_confint <- confint(profile3)
tgamma4_confint <- confint(profile4)
lower <- c(tgamma3_confint$lower, tgamma4_confint$lower)
upper <- c(tgamma3_confint$upper, tgamma4_confint$upper)
tgamma3_confint
tgamma3_confint$lower
profile3 <- tmbprofile(obj = obj_tmb,
name = 3,
trace = FALSE)
profile4 <- tmbprofile(obj = obj_tmb,
name = 4,
trace = FALSE)
# Obtain confidence intervals for working parameters
tgamma_3_confint <- confint(profile3)
tgamma_4_confint <- confint(profile4)
# Group lower bounds and upper bounds
lower <- c(tgamma_3_confint[1], tgamma_4_confint[1])
upper <- c(tgamma_3_confint[2], tgamma_4_confint[2])
# Infer bounds on natural parameters
gamma_1 <- Gamma_w2n(m, lower)
gamma_2 <- Gamma_w2n(m, upper)
gamma_1
gamma_2
Gamma_w2n(m, lower)
profile3 <- tmbprofile(obj = obj_tmb,
name = 3,
trace = FALSE)
profile4 <- tmbprofile(obj = obj_tmb,
name = 4,
trace = FALSE)
# Obtain confidence intervals for working parameters
tgamma_3_confint <- confint(profile3)
tgamma_4_confint <- confint(profile4)
# Group lower bounds and upper bounds
lower <- c(tgamma_3_confint[1], tgamma_4_confint[1])
upper <- c(tgamma_3_confint[2], tgamma_4_confint[2])
# Infer bounds on natural parameters
gamma_1 <- Gamma_w2n(m, lower)
gamma_2 <- Gamma_w2n(m, upper)
gamma_1
gamma_2
c(gamma_1[1,1], gamma_2[1,1])
# Sorted confidence interval for gamma_11
sort(c(gamma_1[1,1], gamma_2[1,1]))
install.packages("bookdown")
