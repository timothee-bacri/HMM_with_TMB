knitr::read_chunk('functions/utils.R')
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
pois.HMM.label.order
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
ordered_lambda <- lambda[sorted_lambda]
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
m = 3
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma[row, col] <- gamma[new_row, new_col]
}
}
# Same for the TPM's standard errors
if (!is.null(gamma_std_error)) {
ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
}
}
}
gamma_std_error
!is.null(gamma_std_error)
lambda_std_error = NULL
gamma_std_error = NULL
delta_std_error = NULL
delta = NULL
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
ordered_lambda <- lambda[sorted_lambda]
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma[row, col] <- gamma[new_row, new_col]
}
}
# Same for the TPM's standard errors
if (!is.null(gamma_std_error)) {
ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
}
}
}
# Re-order the stationary distribution if it is provided
# Generate it otherwise
if (is.null(delta)) {
ordered_delta <- stat.dist(ordered_gamma)
} else {
ordered_delta <- delta[sorted_lambda]
}
# Re-order the standard errors
ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
ordered_delta_std_error <- delta_std_error[sorted_lambda]
result <- list(lambda = ordered_lambda,
gamma = ordered_gamma,
delta = ordered_delta,
lambda_std_error = ordered_lambda_std_error,
gamma_std_error = ordered_gamma_std_error,
delta_std_error = ordered_delta_std_error)
ordered_gamma_std_error
list(lambda = ordered_lambda,
gamma = ordered_gamma,
delta = ordered_delta,
lambda_std_error = ordered_lambda_std_error,
gamma_std_error = ordered_gamma_std_error,
delta_std_error = ordered_delta_std_error)
ordered_lambda_std_error
ordered_lambda_std_error
ordered_delta_std_error
source('D:/Program Data/Dropbox/TMB_HMM/paper1/Data supplements/functions/utils.R')
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
delta = NULL
lambda_std_error = NULL
gamma_std_error = NULL
delta_std_error = NULL
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
m = 3
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
ordered_lambda <- lambda[sorted_lambda]
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma[row, col] <- gamma[new_row, new_col]
}
}
# Same for the TPM's standard errors
ordered_gamma_std_error <- NULL
if (!is.null(gamma_std_error)) {
ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
}
}
}
# Re-order the stationary distribution if it is provided
# Generate it otherwise
if (is.null(delta)) {
ordered_delta <- stat.dist(ordered_gamma)
} else {
ordered_delta <- delta[sorted_lambda]
}
source('D:/Program Data/Dropbox/TMB_HMM/paper1/Data supplements/functions/utils.R')
# Re-order the stationary distribution if it is provided
# Generate it otherwise
if (is.null(delta)) {
ordered_delta <- stat.dist(ordered_gamma)
} else {
ordered_delta <- delta[sorted_lambda]
}
# Re-order the standard errors
ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
ordered_delta_std_error <- delta_std_error[sorted_lambda]
result <- list(lambda = ordered_lambda,
gamma = ordered_gamma,
delta = ordered_delta,
lambda_std_error = ordered_lambda_std_error,
gamma_std_error = ordered_gamma_std_error,
delta_std_error = ordered_delta_std_error)
# Remove the NULL elements
result[sapply(result, is.null)] <- NULL
result
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
pois.HMM.label.order
source("code/main.R")
source("../code/main.R")
library(knitr)
setwd(dir = "../")
suppressMessages(source("../code/main.R"))
library(knitr)
suppressMessages(source("../code/main.R"))
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
pois.HMM.label.order
knitr::read_chunk('functions/utils.R')
pois.HMM.label.order
pois.HMM.label.order
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
par(mar = c(4, 4, .1, .1))
plot(pressure, type = 'b', pch = 19)
knitr::kable(
head(iris, 20), caption = 'Here is a nice table!',
booktabs = TRUE
)
library(TMB)
source("functions/utils.R")
load("data/fetal-lamb.RData")
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
}
lambda <- seq(quantile(tinn_data, 0.1), quantile(tinn_data, 0.9), length.out = m)
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
m <- 2
load("data/tinnitus.RData")
# Parameters and covariates
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
}
lambda <- seq(quantile(tinn_data, 0.1), quantile(tinn_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
# Parameters & covariates for TMB
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = tinn_data, m = m)
obj <- MakeADFun(TMB_data, working_params, DLL = "poi_hmm", silent = TRUE)
# Estimation via a wrapper for nlminb
tmb_gh <- TMB.estimate(TMB_data = TMB_data,
parameters = working_params,
MakeADFun_obj = obj,
gradient = TRUE,
hessian = TRUE)
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
load("data/tinnitus.RData")
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
}
lambda <- seq(quantile(tinn_data, 0.1), quantile(tinn_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = tinn_data, m = m)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
DATA_SIZE_SIMU <- 2000
m <- 2
# Generate parameters
lambda <- seq(1, 4, length.out = m)
# Create the transition probability matrix with 0.8 on its diagonal
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
delta <- stat.dist(gamma)
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.1 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.9
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
load("data/tinnitus.RData")
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
}
lambda <- seq(quantile(tinn_data, 0.1), quantile(tinn_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = tinn_data, m = m)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
DATA_SIZE_SIMU <- 2000
m <- 2
# Generate parameters
lambda <- seq(1, 4, length.out = m)
# Create the transition probability matrix with 0.8 on its diagonal
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
delta <- stat.dist(gamma)
simu_data <- pois.HMM.generate_sample(ns = DATA_SIZE_SIMU,
mod = list(m = m,
lambda = lambda,
gamma = gamma,
delta = delta))
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.1 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.9
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
simu_data
pois.HMM.generate_sample
simu_data <- pois.HMM.generate_sample(ns = DATA_SIZE_SIMU,
mod = list(m = m,
lambda = lambda,
gamma = gamma,
delta = delta))$data
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.1 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.9
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
DATA_SIZE_SIMU <- 2000
m <- 2
# Generate parameters
lambda <- seq(1, 4, length.out = m)
# Create the transition probability matrix with 0.8 on its diagonal
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
delta <- stat.dist(gamma)
simu_data <- pois.HMM.generate_sample(ns = DATA_SIZE_SIMU,
mod = list(m = m,
lambda = lambda,
gamma = gamma,
delta = delta))$data
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.1 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.9
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = simu_data, m = m)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.15 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.85
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = simu_data, m = m)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
lambda
DATA_SIZE_SIMU <- 2000
m <- 2
# Generate parameters
lambda <- seq(10, 14, length.out = m)
# Create the transition probability matrix with 0.8 on its diagonal
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
delta <- stat.dist(gamma)
simu_data <- pois.HMM.generate_sample(ns = DATA_SIZE_SIMU,
mod = list(m = m,
lambda = lambda,
gamma = gamma,
delta = delta))$data
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.2 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.8
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = simu_data, m = m)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
lambda
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.4 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.6
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
working_params <- pois.HMM.pn2pw(m, lambda, gamma)
TMB_data <- list(x = simu_data, m = m)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, working_params,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Check convergence
mod_tmb$convergence == 0
# Results
summary(sdreport(obj_tmb), "report")
# Parameters and covariates
m <- 2
if (m == 1) {
gamma <- matrix(1)
} else {
gamma <- matrix(0.4 / (m - 1), nrow = m, ncol = m)
diag(gamma) <- 0.6
}
lambda <- seq(quantile(simu_data, 0.1), quantile(simu_data, 0.9), length.out = m)
delta <- stat.dist(gamma)
lambda
