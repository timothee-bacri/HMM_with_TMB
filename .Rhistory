suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
library(TMB)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
m <- 2
TMB_data <- list(x = tinn_data, m = m)
load("data/tinnitus.RData")
TMB_data <- list(x = tinn_data, m = m)
# Initial set of parameters
lambda_init <- c(1, 3)
gamma_init <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda, gamma)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Initial set of parameters
lambda_init <- c(1, 3)
gamma_init <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda_init, gamma_init)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Bootstrap procedure
bootstrap_estimates <- data.frame()
DATA_SIZE <- length(lamb_data)
# Set how many parametric bootstrap samples we create
BOOTSTRAP_SAMPLES <- 1000
DATA_SIZE <- length(tinn_data)
# Set how many parametric bootstrap samples we create
BOOTSTRAP_SAMPLES <- 1000
# ML parameters
ML_working_estimates <- obj_tmb$env$last.par.best
ML_natural_estimates <- obj_tmb$report(ML_working_estimates)
gamma <- ML_natural_estimates$gamma
lambda <- ML_natural_estimates$lambda
delta <- ML_natural_estimates$delta
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
m <- 2
load("data/tinnitus.RData")
TMB_data <- list(x = tinn_data, m = m)
# Initial set of parameters
lambda_init <- c(1, 3)
gamma_init <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda_init, gamma_init)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Bootstrap procedure
bootstrap_estimates <- data.frame()
DATA_SIZE <- length(tinn_data)
# Set how many parametric bootstrap samples we create
BOOTSTRAP_SAMPLES <- 1000
# ML parameters
ML_working_estimates <- obj_tmb$env$last.par.best
ML_natural_estimates <- obj_tmb$report(ML_working_estimates)
lambda <- ML_natural_estimates$lambda
gamma <- ML_natural_estimates$gamma
delta <- ML_natural_estimates$delta
# MLE
ML_working_estimates <- obj_tmb$env$last.par.best
ML_natural_estimates <- obj_tmb$report(ML_working_estimates)
lambda <- ML_natural_estimates$lambda
gamma <- ML_natural_estimates$gamma
delta <- ML_natural_estimates$delta
PARAMS_NAMES <- c("lambda", "gamma", "delta")
BOOTSTRAP_SAMPLES
# Set how many parametric bootstrap samples we create
BOOTSTRAP_SAMPLES <- 10
# Generate a sample based on mod, and ensure a HMM can be estimated on it
# with testing_params as initial parameters
temp <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE,
mod = list(m = m,
lambda = lambda,
gamma = gamma),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init))$natural_parameters
pois.HMM.generate_estimable_sample
load("data/tinnitus.RData")
# Generate a sample based on mod, and ensure a HMM can be estimated on it
# with testing_params as initial parameters
temp <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE,
mod = list(m = m,
lambda = lambda,
gamma = gamma),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init))$natural_parameters
pois.HMM.generate_estimable_sample
source('D:/Program Data/Dropbox/TMB_HMM/paper1/Data supplements/functions/utils.R')
pois.HMM.generate_estimable_sample
# Generate a sample based on mod, and ensure a HMM can be estimated on it
# with testing_params as initial parameters
temp <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE,
mod = list(m = m,
lambda = lambda,
gamma = gamma),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init))$natural_parameters
# The values from gamma are taken columnwise
natural_parameters <- unlist(temp[PARAMS_NAMES])
len_par <- length(natural_parameters)
for (idx_sample in 1:BOOTSTRAP_SAMPLES) {
# Generate a sample based on mod, and ensure a HMM can be estimated on it
# with testing_params as initial parameters
temp <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE,
mod = list(m = m,
lambda = lambda,
gamma = gamma),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init))$natural_parameters
# The values from gamma are taken columnwise
natural_parameters <- unlist(temp[PARAMS_NAMES])
len_par <- length(natural_parameters)
bootstrap_estimates[idx_sample, 1:len_par] <- natural_parameters
}
set.seed(123)
library(TMB)
dyn.load(dynlib("code/poi_hmm"))
m <- 2
# Initial set of parameters
lambda_init <- c(1, 3)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda_init, gamma_init)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Bootstrap procedure
bootstrap_estimates <- data.frame()
DATA_SIZE <- length(tinn_data)
# Set how many parametric bootstrap samples we create
BOOTSTRAP_SAMPLES <- 10
# MLE
ML_working_estimates <- obj_tmb$env$last.par.best
ML_natural_estimates <- obj_tmb$report(ML_working_estimates)
lambda <- ML_natural_estimates$lambda
gamma <- ML_natural_estimates$gamma
delta <- ML_natural_estimates$delta
PARAMS_NAMES <- c("lambda", "gamma", "delta")
for (idx_sample in 1:BOOTSTRAP_SAMPLES) {
# Generate a sample based on mod, and ensure a HMM can be estimated on it
# with testing_params as initial parameters
temp <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE,
mod = list(m = m,
lambda = lambda,
gamma = gamma),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init))$natural_parameters
# The values from gamma are taken columnwise
natural_parameters <- unlist(temp[PARAMS_NAMES])
len_par <- length(natural_parameters)
bootstrap_estimates[idx_sample, 1:len_par] <- natural_parameters
}
# Lower and upper (2.5% and 97.5%) bounds
q <- apply(bootstrap_estimates, 2, function(par_estimate) {
quantile(par_estimate, probs = c(0.025, 0.975))
})
q
PARAMS_NAMES
PARAMS_NAMES <- paste0(rep("lambda", m), 1:m)
# Get row and column indexes for gamma instead of the default
# columnwise index: the default indexes are 1:m for the 1st column,
# then (m + 1):(2 * m) for the 2nd, etc...
for (gamma_idx in 1:m ^ 2) {
row <- (gamma_idx - 1) %% m + 1
col <- (gamma_idx - 1) %/% m + 1
row_col_idx <- c(row, col)
PARAMS_NAMES <- c(PARAMS_NAMES,
paste0("gamma",
paste0(row_col_idx, collapse = "")))
}
PARAMS_NAMES <- c(PARAMS_NAMES,
paste0(rep("delta", m), 1:m))
PARAMS_NAMES
set.seed(123)
library(TMB)
TMB::compile("code/poi_hmm.cpp")
dyn.load(dynlib("code/poi_hmm"))
source("functions/utils.R")
m <- 2
load("data/tinnitus.RData")
TMB_data <- list(x = tinn_data, m = m)
# Initial set of parameters
lambda_init <- c(1, 3)
gamma_init <- matrix(c(0.8, 0.2,
0.2, 0.8), byrow = TRUE, nrow = m)
# Turn them into working parameters
parameters <- pois.HMM.pn2pw(m, lambda_init, gamma_init)
# Build the TMB object
obj_tmb <- MakeADFun(TMB_data, parameters,
DLL = "poi_hmm", silent = TRUE)
# Optimize
mod_tmb <- nlminb(start = obj_tmb$par,
objective = obj_tmb$fn,
gradient = obj_tmb$gr,
hessian = obj_tmb$he)
# Bootstrap procedure
bootstrap_estimates <- data.frame()
DATA_SIZE <- length(tinn_data)
# Set how many parametric bootstrap samples we create
BOOTSTRAP_SAMPLES <- 10
# MLE
ML_working_estimates <- obj_tmb$env$last.par.best
ML_natural_estimates <- obj_tmb$report(ML_working_estimates)
lambda <- ML_natural_estimates$lambda
gamma <- ML_natural_estimates$gamma
delta <- ML_natural_estimates$delta
PARAMS_NAMES <- c("lambda", "gamma", "delta")
for (idx_sample in 1:BOOTSTRAP_SAMPLES) {
# Generate a sample based on mod, and ensure a HMM can be estimated on it
# with testing_params as initial parameters
temp <- pois.HMM.generate_estimable_sample(ns = DATA_SIZE,
mod = list(m = m,
lambda = lambda,
gamma = gamma),
testing_params = list(m = m,
lambda = lambda_init,
gamma = gamma_init))$natural_parameters
# The values from gamma are taken columnwise
natural_parameters <- unlist(temp[PARAMS_NAMES])
len_par <- length(natural_parameters)
bootstrap_estimates[idx_sample, 1:len_par] <- natural_parameters
}
# Lower and upper (2.5% and 97.5%) bounds
q <- apply(bootstrap_estimates, 2, function(par_estimate) {
quantile(par_estimate, probs = c(0.025, 0.975))
})
PARAMS_NAMES <- paste0(rep("lambda", m), 1:m)
# Get row and column indexes for gamma instead of the default
# columnwise index: the default indexes are 1:m for the 1st column,
# then (m + 1):(2 * m) for the 2nd, etc...
for (gamma_idx in 1:m ^ 2) {
row <- (gamma_idx - 1) %% m + 1
col <- (gamma_idx - 1) %/% m + 1
row_col_idx <- c(row, col)
PARAMS_NAMES <- c(PARAMS_NAMES,
paste0("gamma",
paste0(row_col_idx, collapse = "")))
}
PARAMS_NAMES <- c(PARAMS_NAMES,
paste0(rep("delta", m), 1:m))
bootstrap_CI <- data.frame("Parameter" = PARAMS_NAMES,
"Estimate" = c(lambda, gamma, delta),
"Lower bound" = q[1, ],
"Upper bound" = q[2, ])
print(bootstrap_CI, row.names = FALSE)
# print(counter)
# plot(x = 1:BOOTSTRAP_SAMPLES, y = nll)
# hist(nll)
# apply(bootstrap_estimates[, 1:2], 2, function(est) {
#   hist(est, breaks = "FD")
# })
# print(paste("Lack of convergence/missing results", counter2, counter1, "times"))
# myAIC[, "pref"] <- ifelse(myAIC[, "1state"] <= myAIC[, "2state"], 1, 2)
# myBIC[, "pref"] <- ifelse(myBIC[, "1state"] <= myBIC[, "2state"], 1, 2)
# print(paste("AIC prefers 1 state", sum(myAIC[, "pref"] == 1), "times, and 2 states", sum(myAIC[, "pref"] == 2), "times"))
# print(paste("BIC prefers 1 state", sum(myBIC[, "pref"] == 1), "times, and 2 states", sum(myBIC[, "pref"] == 2), "times"))
#
#
# print(paste(counter1, "don't reach any result"))
# # print(paste("conv codes:", conv1))
# print(paste(counter2, "don't converge successfully"))
# # print(paste("conv codes:", conv2))
# print(paste(counter3, "parameters are NA"))
# # print(paste("gamma over the threshold", counter_threshold_gamma, "times"))
# print(paste("lambda under the threshold", counter_threshold_lambda, "times"))
NULL[2]
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
pois.HMM.label.order
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
ordered_lambda <- lambda[sorted_lambda]
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
m = 3
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma[row, col] <- gamma[new_row, new_col]
}
}
# Same for the TPM's standard errors
if (!is.null(gamma_std_error)) {
ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
}
}
}
gamma_std_error
!is.null(gamma_std_error)
lambda_std_error = NULL
gamma_std_error = NULL
delta_std_error = NULL
delta = NULL
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
ordered_lambda <- lambda[sorted_lambda]
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma[row, col] <- gamma[new_row, new_col]
}
}
# Same for the TPM's standard errors
if (!is.null(gamma_std_error)) {
ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
}
}
}
# Re-order the stationary distribution if it is provided
# Generate it otherwise
if (is.null(delta)) {
ordered_delta <- stat.dist(ordered_gamma)
} else {
ordered_delta <- delta[sorted_lambda]
}
# Re-order the standard errors
ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
ordered_delta_std_error <- delta_std_error[sorted_lambda]
result <- list(lambda = ordered_lambda,
gamma = ordered_gamma,
delta = ordered_delta,
lambda_std_error = ordered_lambda_std_error,
gamma_std_error = ordered_gamma_std_error,
delta_std_error = ordered_delta_std_error)
ordered_gamma_std_error
list(lambda = ordered_lambda,
gamma = ordered_gamma,
delta = ordered_delta,
lambda_std_error = ordered_lambda_std_error,
gamma_std_error = ordered_gamma_std_error,
delta_std_error = ordered_delta_std_error)
ordered_lambda_std_error
ordered_lambda_std_error
ordered_delta_std_error
source('D:/Program Data/Dropbox/TMB_HMM/paper1/Data supplements/functions/utils.R')
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
delta = NULL
lambda_std_error = NULL
gamma_std_error = NULL
delta_std_error = NULL
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
m = 3
# Get the indexes of the sorted states
# according to ascending lambda
# sorted_lambda contains the permutations needed
sorted_lambda <- sort(lambda, index.return = TRUE)$ix
ordered_lambda <- lambda[sorted_lambda]
# Re-order the TPM according to the switched states
# in the sorted lambda
ordered_gamma <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma[row, col] <- gamma[new_row, new_col]
}
}
# Same for the TPM's standard errors
ordered_gamma_std_error <- NULL
if (!is.null(gamma_std_error)) {
ordered_gamma_std_error <- matrix(0, nrow = m, ncol = m)
for (col in 1:m) {
new_col <- which(sorted_lambda == col)
for (row in 1:m) {
new_row <- which(sorted_lambda == row)
ordered_gamma_std_error[row, col] <- gamma_std_error[new_row, new_col]
}
}
}
# Re-order the stationary distribution if it is provided
# Generate it otherwise
if (is.null(delta)) {
ordered_delta <- stat.dist(ordered_gamma)
} else {
ordered_delta <- delta[sorted_lambda]
}
source('D:/Program Data/Dropbox/TMB_HMM/paper1/Data supplements/functions/utils.R')
# Re-order the stationary distribution if it is provided
# Generate it otherwise
if (is.null(delta)) {
ordered_delta <- stat.dist(ordered_gamma)
} else {
ordered_delta <- delta[sorted_lambda]
}
# Re-order the standard errors
ordered_lambda_std_error <- lambda_std_error[sorted_lambda]
ordered_delta_std_error <- delta_std_error[sorted_lambda]
result <- list(lambda = ordered_lambda,
gamma = ordered_gamma,
delta = ordered_delta,
lambda_std_error = ordered_lambda_std_error,
gamma_std_error = ordered_gamma_std_error,
delta_std_error = ordered_delta_std_error)
# Remove the NULL elements
result[sapply(result, is.null)] <- NULL
result
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
pois.HMM.label.order
source("code/main.R")
source("../code/main.R")
library(knitr)
setwd(dir = "../")
suppressMessages(source("../code/main.R"))
library(knitr)
suppressMessages(source("../code/main.R"))
library(knitr)
setwd(dir = "../")
suppressMessages(source("code/main.R"))
knitr::read_chunk('functions/utils.R')
pois.HMM.label.order
knitr::read_chunk('functions/utils.R')
pois.HMM.label.order
pois.HMM.label.order
lambda <- c(30, 10, 20)
gamma <- matrix(c(11, 12, 13,
21, 22, 23,
31, 32, 33), byrow = TRUE, ncol = 3)
pois.HMM.label.order(m = 3, lambda, gamma)
par(mar = c(4, 4, .1, .1))
plot(pressure, type = 'b', pch = 19)
knitr::kable(
head(iris, 20), caption = 'Here is a nice table!',
booktabs = TRUE
)
library(TMB)
source("functions/utils.R")
load("data/fetal-lamb.RData")
