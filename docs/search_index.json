[["principles-of-using-tmb-for-maximum-likelihood-estimation.html", "Chapter 2 Principles of using TMB for Maximum Likelihood Estimation 2.1 Setting up TMB 2.2 Getting started with a linear regression 2.3 Extending the C++ negative log-likelihood", " Chapter 2 Principles of using TMB for Maximum Likelihood Estimation 2.1 Setting up TMB In order to run the scripts and example code, you first need to set up TMB by going through the following steps: Install Rtools Install the R-package TMB (Kristensen 2021) by executing the following code in R: install.packages(&quot;TMB&quot;) (Optional) Setup error debugging in RStudio by running the command TMB::setupRstudio() Advanced use is detailed in https://kaskr.github.io/adcomp/_book/Tutorial.html 2.2 Getting started with a linear regression Let \\({\\boldsymbol x}\\) and \\({\\boldsymbol y}\\) denote the predictor and response vector, respectively, both of length \\(n\\). For a simple linear regression model with intercept \\(a\\) and slope \\(b\\), the negative log-likelihood equals \\[\\begin{equation*} - \\log L(a, b, \\sigma^2) = - \\sum_{i=1}^n \\log(\\phi(y_i; a + bx_i, \\sigma^2)), \\end{equation*}\\] where \\(\\phi(\\cdot; \\mu, \\sigma^2)\\) corresponds to the density function of the univariate normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\). The use of TMB requires the (negative) log-likelihood function to be coded in C++ under a specific template, which is then loaded into R. The minimization of this function and other post-processing procedures are all carried out in R. Therefore, we require two files. The first file, named linreg.cpp, is written in C++ and defines the objective function, i.e. the negative log-likelihood (nll) function of the linear model. #include &lt;TMB.hpp&gt; //import the TMB template template&lt;class Type&gt; Type objective_function&lt;Type&gt;::operator() () { DATA_VECTOR(y); // Data vector y passed from R DATA_VECTOR(x); // Data vector x passed from R PARAMETER(a); // Parameter a passed from R PARAMETER(b); // Parameter b passed from R PARAMETER(tsigma); // Parameter sigma (transformed, on log-scale) // passed from R // Transform tsigma back to natural scale Type sigma = exp(tsigma); // Declare negative log-likelihood Type nll = - sum(dnorm(y, a + b * x, sigma, true)); // Necessary for inference on sigma, not only tsigma ADREPORT(sigma); return nll; } The second file needed is written in R and serves for compiling the nll function defined above and carrying out the estimation procedure by numerical optimization of the nll function. The .R file (shown below) carries out the compilation of the C++ file and minimization of the nll function: # Loading TMB package library(TMB) # Compilation. The compiler returns 0 if the compilation of # the cpp file was successful TMB::compile(&quot;code/linreg.cpp&quot;) ## [1] 0 # Dynamic loading of the compiled cpp file dyn.load(dynlib(&quot;code/linreg&quot;)) # Generate the data for our test sample set.seed(123) data &lt;- list(y = rnorm(20) + 1:20, x = 1:20) parameters &lt;- list(a = 0, b = 0, tsigma = 0) # Instruct TMB to create the likelihood function obj_linreg &lt;- MakeADFun(data, parameters, DLL = &quot;linreg&quot;, silent = TRUE) # Optimization of the objective function with nlminb mod_linreg &lt;- nlminb(obj_linreg$par, obj_linreg$fn, obj_linreg$gr, obj_linreg$he) mod_linreg$par ## a b tsigma ## 0.31009251 0.98395536 -0.05814649 Now that the optimization is taken care of, we can display the estimates with standard errors using the sdreport function. sdreport(obj_linreg) ## sdreport(.) result ## Estimate Std. Error ## a 0.31009251 0.43829087 ## b 0.98395536 0.03658782 ## tsigma -0.05814649 0.15811383 ## Maximum gradient component: 1.300261e-10 If we use summary on this object, we also get the variables we have passed to ADREPORT in the linreg.cpp file. In this example, this is only the residual standard deviation; sigma. summary(sdreport(obj_linreg)) ## Estimate Std. Error ## a 0.31009251 0.43829087 ## b 0.98395536 0.03658782 ## tsigma -0.05814649 0.15811383 ## sigma 0.94351172 0.14918225 The select argument restricts the output to variables passed by ADREPORT(variable_name); in the cpp file. As we will see in Wald-type, this lets us derive confidence intervals for these natural parameters easily. summary(sdreport(obj_linreg), select = &quot;report&quot;) ## Estimate Std. Error ## sigma 0.9435117 0.1491823 Certainly, you would not build a TMB model to fit a linear regression. We can use standard R functions for that. Therefore, we use stats::lm on the same data and compare the estimates to those obtained by TMB. rbind( &quot;lm&quot; = lm(y ~ x, data = data)$coef, # linear regression using R &quot;TMB&quot; = mod_linreg$par[1:2] # intercept and slope from TMB fit ) ## (Intercept) x ## lm 0.3100925 0.9839554 ## TMB 0.3100925 0.9839554 As we can see, the parameter estimates are exactly the same. 2.3 Extending the C++ negative log-likelihood Sometimes it is useful to write subroutines as a separate function that can be used within your TMB likelihood function. This can increase readability of your code and reduce the number of lines of code in your main cpp file. Writing extra files to define functions compatible with TMB requires some care, as these must follow TMBs template. To illustrate how this works, we add a separate function to the linreg.cpp example. The following function does not do anything meaningful, but is just meant to show you how you can add write an additional function and load it into your C++. We start by writing the subroutine function as a separate file called functions/utils_linreg.cpp. template&lt;class Type&gt; matrix&lt;Type&gt; function_example(matrix&lt;Type&gt; mat_example) { // This function doesn&#39;t do anything meaningful matrix&lt;Type&gt; mat(2, 3); mat.setOnes(); mat.row(1) &lt;&lt; 5, 5, 5; mat(0, 2) = mat.row(1).sum(); return mat; } We then import it into linreg.cpp (code/linreg_utils.cpp). #include &lt;TMB.hpp&gt; //import the TMB template #include &quot;../functions/utils_linreg.cpp&quot; template&lt;class Type&gt; Type objective_function&lt;Type&gt;::operator() () { DATA_VECTOR(y); // Data vector y passed from R DATA_VECTOR(x); // Data vector x passed from R PARAMETER(a); // Parameter a passed from R PARAMETER(b); // Parameter b passed from R PARAMETER(tsigma); // Parameter sigma (transformed, on log-scale) // passed from R // Transform tsigma back to natural scale Type sigma = exp(tsigma); // Declare negative log-likelihood Type nll = - sum(dnorm(y, a + b * x, sigma, true)); // Necessary for inference on sigma, not only tsigma ADREPORT(sigma); /* This is a useless example to show how to manipulate matrices * in C++ * This creates a matrix of 2 rows and 3 columns. * The Eigen library is used to manipulate vectors, arrays, matrices... */ matrix&lt;Type&gt; mat_example(2, 3); mat_example &lt;&lt; 1, 2, 3, 4, 5, 6; matrix&lt;Type&gt; mat_example2 = function_example(mat_example); // This lets us retrieve any variables in a nice format REPORT(mat_example); REPORT(mat_example2); return nll; } References "]]
