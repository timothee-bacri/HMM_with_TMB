[["multivariate-gaussian-hmm.html", " 8 Multivariate Gaussian HMM 8.1 Dataset 8.2 Likelihood function 8.3 Estimation 8.4 Results 8.5 Residuals", " 8 Multivariate Gaussian HMM Multivariate Gaussian HMMs with TMB are very similar to the previous Poisson HMM. The main changes are the distribution parameters being changed from \\({\\boldsymbol\\lambda}\\) to \\({\\boldsymbol\\mu}\\) and \\({\\boldsymbol\\Sigma}\\). In turn, these cause the density function to change from dpois to dmvnorm (and from rpois to rmvnorm for simulations) from the mvtnorm (Genz, Bretz, Miwa, Mi, &amp; Hothorn, 2021) package. Many functions available in functions/utils.R have been adapted for the multivariate Gaussian case in functions/mvnorm_utils.R. We detail below an example of a two-state trivariate Gaussian HMM with TMB. 8.1 Dataset The data is generated with the function below (similarly to the Poisson case) 8.2 Likelihood function The Gaussian negative log-likelihood in TMB can be coded as #include &lt;TMB.hpp&gt; #include &quot;../functions/norm_utils.cpp&quot; // Likelihood for a normal hidden markov model. template&lt;class Type&gt; Type objective_function&lt;Type&gt;::operator() () { // Data DATA_VECTOR(x); // timeseries vector DATA_INTEGER(m); // Number of states m // Parameters PARAMETER_VECTOR(tmu); // conditional means PARAMETER_VECTOR(tsigma); // conditional log_sd&#39;s PARAMETER_VECTOR(tgamma); // m(m-1) working parameters of TPM // PARAMETER_VECTOR(tdelta); // m-1 working parameters of initial distribution // Transform working parameters to natural parameters: vector&lt;Type&gt; mu = tmu; vector&lt;Type&gt; sigma = tsigma.exp(); matrix&lt;Type&gt; gamma = gamma_w2n(m, tgamma); // vector&lt;Type&gt; delta = delta_w2n(m, tdelta); // Construct stationary distribution vector&lt;Type&gt; delta = stat_dist(m, gamma); // Get number of timesteps (n) int n = x.size(); // Evaluate conditional distribution: Put conditional probabilities // of observed x in n times m matrix (one column for each state) matrix&lt;Type&gt; emission_probs(n, m); matrix&lt;Type&gt; row1vec(1, m); row1vec.setOnes(); for (int i = 0; i &lt; n; i++) { if (x[i] != x[i]) { // f != f returns true if and only if f is NaN. // Replace missing values (NA in R, NaN in C++) with 1 emission_probs.row(i) = row1vec; } else { emission_probs.row(i) = dnorm(x(i), mu, sigma, false); } } // Corresponds to the book page 333 matrix&lt;Type&gt; foo, P; Type mllk, sumfoo, lscale; foo = (delta * vector&lt;Type&gt;(emission_probs.row(0))).matrix(); sumfoo = foo.sum(); lscale = log(sumfoo); foo.transposeInPlace(); foo /= sumfoo; for (int i = 2; i &lt;= n; i++) { P = emission_probs.row(i - 1); foo = ((foo * gamma).array() * P.array()).matrix(); sumfoo = foo.sum(); lscale += log(sumfoo); foo /= sumfoo; } mllk = -lscale; // Use adreport on variables for which we want standard errors ADREPORT(mu); ADREPORT(sigma); ADREPORT(gamma); ADREPORT(delta); // Variables we need for local decoding and in a convenient format REPORT(mu); REPORT(sigma); REPORT(gamma); REPORT(delta); REPORT(n); // REPORT(emission_probs); REPORT(mllk); return mllk; } and requires the following utility functions. // Function transforming working parameters in initial distribution // to natural parameters template&lt;class Type&gt; vector&lt;Type&gt; delta_w2n(int m, vector&lt;Type&gt; tdelta) { vector&lt;Type&gt; delta(m); vector&lt;Type&gt; foo(m); if (m == 1) return Type(1); // set first element to one. // Fill in the last m - 1 elements with working parameters // and take exponential foo &lt;&lt; Type(1), tdelta.exp(); // normalize delta = foo / foo.sum(); return delta; } // Function transforming the working parameters in TPM to // natural parameters (w2n) template&lt;class Type&gt; matrix&lt;Type&gt; gamma_w2n(int m, vector&lt;Type&gt; tgamma) { // Construct m x m identity matrix matrix&lt;Type&gt; gamma(m, m); gamma.setIdentity(); if (m == 1) return gamma; // Fill offdiagonal elements with working parameters column-wise: int idx = 0; for (int i = 0; i &lt; m; i++){ for (int j = 0; j &lt; m; j++){ if (j != i){ // Fill gamma according to mapping and take exponential gamma(j, i) = tgamma.exp()(idx); idx++; } } } // Normalize each row: vector&lt;Type&gt; cs = gamma.rowwise().sum(); for (int i = 0; i &lt; m; i++) gamma.row(i) /= cs[i]; return gamma; } // Function computing the stationary distribution of a Markov chain template&lt;class Type&gt; vector&lt;Type&gt; stat_dist(int m, matrix&lt;Type&gt; gamma) { // Construct stationary distribution matrix&lt;Type&gt; I(m, m); matrix&lt;Type&gt; U(m, m); matrix&lt;Type&gt; row1vec(1, m); U = U.setOnes(); I = I.setIdentity(); row1vec.setOnes(); matrix&lt;Type&gt; A = I - gamma + U; matrix&lt;Type&gt; Ainv = A.inverse(); matrix&lt;Type&gt; deltamat = row1vec * Ainv; vector&lt;Type&gt; delta = deltamat.row(0); return delta; } 8.3 Estimation source(&quot;code/packages.R&quot;) ## Loading required package: TMB ## Warning: package &#39;TMB&#39; was built under R version 4.1.2 ## Loading required package: markovchain ## Package: markovchain ## Version: 0.8.6 ## Date: 2021-05-17 ## BugReport: https://github.com/spedygiorgio/markovchain/issues ## Loading required package: microbenchmark ## Warning: package &#39;microbenchmark&#39; was built under R version 4.1.2 ## Loading required package: ggplot2 ## Loading required package: optimr ## Loading required package: ggthemes ## Loading required package: knitr ## Loading required package: xtable ## Loading required package: R.utils ## Loading required package: R.oo ## Loading required package: R.methodsS3 ## R.methodsS3 v1.8.1 (2020-08-26 16:20:06 UTC) successfully loaded. See ?R.methodsS3 for help. ## R.oo v1.24.0 (2020-08-26 16:11:58 UTC) successfully loaded. See ?R.oo for help. ## ## Attaching package: &#39;R.oo&#39; ## The following object is masked from &#39;package:R.methodsS3&#39;: ## ## throw ## The following object is masked from &#39;package:TMB&#39;: ## ## compile ## The following objects are masked from &#39;package:methods&#39;: ## ## getClasses, getMethods ## The following objects are masked from &#39;package:base&#39;: ## ## attach, detach, load, save ## R.utils v2.11.0 (2021-09-26 08:30:02 UTC) successfully loaded. See ?R.utils for help. ## ## Attaching package: &#39;R.utils&#39; ## The following object is masked from &#39;package:utils&#39;: ## ## timestamp ## The following objects are masked from &#39;package:base&#39;: ## ## cat, commandArgs, getOption, inherits, isOpen, nullfile, parse, ## warnings ## Loading required package: lubridate ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:markovchain&#39;: ## ## period ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union ## Loading required package: readr ## Warning: package &#39;readr&#39; was built under R version 4.1.2 ## Loading required package: tidyverse ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 -- ## v tibble 3.1.6 v dplyr 1.0.7 ## v tidyr 1.1.4 v stringr 1.4.0 ## v purrr 0.3.4 v forcats 0.5.1 ## Warning: package &#39;tibble&#39; was built under R version 4.1.2 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x lubridate::as.difftime() masks base::as.difftime() ## x lubridate::date() masks base::date() ## x tidyr::extract() masks R.utils::extract() ## x dplyr::filter() masks stats::filter() ## x lubridate::intersect() masks base::intersect() ## x dplyr::lag() masks stats::lag() ## x lubridate::period() masks markovchain::period() ## x lubridate::setdiff() masks base::setdiff() ## x lubridate::union() masks base::union() ## Loading required package: ggpubr ## Loading required package: marqLevAlg ## Loading required package: doParallel ## Loading required package: foreach ## ## Attaching package: &#39;foreach&#39; ## The following objects are masked from &#39;package:purrr&#39;: ## ## accumulate, when ## Loading required package: iterators ## Loading required package: parallel ## Loading required package: mvtnorm source(&quot;functions/mvnorm_utils.R&quot;) # TMB::precompile() TMB::compile(&quot;code/mvnorm_hmm.cpp&quot;) ## [1] 0 dyn.load(TMB::dynlib(&quot;code/mvnorm_hmm&quot;)) set.seed(123) # Two states m &lt;- 2 # Trivariate Normal distribution p &lt;- 3 # One row per state, one column per dimension of the data mu &lt;- matrix(c(6,8,9, 1,2,3), nrow = m, ncol = p, byrow = TRUE) # Two covariance matrices sigma1 &lt;- matrix(c(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0), nrow = p, ncol = p, byrow = TRUE) sigma2 &lt;- matrix(c(2.0, 1.5, 1.5, 1.5, 2.0, 1.5, 1.5, 1.5, 2.0), nrow = p, ncol = p, byrow = TRUE) # We store them in an array for convenience, making them # easily distinguishable at a glance when displayed sigma &lt;- array(c(sigma1, sigma2), dim = c(p, p, m)) gamma &lt;- matrix(c(0.95, 0.05, 0.15, 0.85), byrow = TRUE, nrow = m, ncol = m) mod &lt;- list(m = m, mu = mu, sigma = sigma, gamma = gamma) # Similarly to the Poisson case, we can generate data. # Here, we generate a trivariate Gaussian sample of size 1000. TMBdata &lt;- mvnorm.HMM.generate.sample(1000, mod) # TMB requires a list TMB_data &lt;- list(x = TMBdata$data, m = m) # TMB requires the parameters to be either vectors, matrices, or arrays. # For simplicity, we pass the parameters as a list of vectors and matrices. pw &lt;- mvnorm.HMM.pn2pw(m = m, mu = mu, sigma = sigma, gamma = gamma) obj_tmb &lt;- TMB::MakeADFun(data = TMB_data, parameters = pw, DLL = &quot;mvnorm_hmm&quot;, silent = TRUE) res &lt;- nlminb(start = obj_tmb$par, objective = obj_tmb$fn, gradient = obj_tmb$gr, hessian = obj_tmb$he) mvnorm.HMM.label.order(m = m, mu = mu, sigma = sigma, gamma = gamma) ## $mu ## [,1] [,2] ## [1,] 8 6 ## [2,] 2 1 ## ## $sigma ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 2.0 1.5 1.5 ## [2,] 1.5 2.0 1.5 ## [3,] 1.5 1.5 2.0 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1.0 0.5 0.5 ## [2,] 0.5 1.0 0.5 ## [3,] 0.5 0.5 1.0 ## ## ## $gamma ## [,1] [,2] ## [1,] 0.85 0.15 ## [2,] 0.05 0.95 ## ## $delta ## [1] 0.25 0.75 ## ## $ordered_mu_indices ## [1] 2 1 ## ## $ordered_sigma_indices ## [1] 2 1 ## ## $ordered_gamma_vector_indices ## [1] 4 3 2 1 ## ## $ordered_delta_indices ## [1] 2 1 8.4 Results summary(sdreport(obj_tmb), &quot;report&quot;) ## Estimate Std. Error ## mu 5.97933189 0.037563682 ## mu 7.97466265 0.036769886 ## mu 9.03496308 0.036893647 ## mu 1.10579193 0.079577526 ## mu 2.01696329 0.082568262 ## mu 3.06944256 0.081165357 ## sigma 0.98949937 0.052850720 ## sigma 0.46755142 0.040689252 ## sigma 0.45275405 0.040488620 ## sigma 0.46755142 0.040689252 ## sigma 0.94526437 0.050668944 ## sigma 0.47948079 0.040495684 ## sigma 0.45275405 0.040488620 ## sigma 0.47948079 0.040495684 ## sigma 0.94984027 0.051242766 ## sigma 1.84609954 0.155927347 ## sigma 1.39862795 0.143048208 ## sigma 1.32776440 0.138042910 ## sigma 1.39862795 0.143048208 ## sigma 1.98516354 0.167983567 ## sigma 1.43015056 0.145538312 ## sigma 1.32776440 0.138042910 ## sigma 1.43015056 0.145538312 ## sigma 1.92236070 0.161913458 ## gamma 0.94337605 0.008707558 ## gamma 0.13555932 0.019818312 ## gamma 0.05662395 0.008707558 ## gamma 0.86444068 0.019818312 ## delta 0.70536482 0.043981080 ## delta 0.29463518 0.043981080 # More readable estimates report &lt;- obj_tmb$report() report ## $mu ## [,1] [,2] ## [1,] 5.979332 1.105792 ## [2,] 7.974663 2.016963 ## [3,] 9.034963 3.069443 ## ## $sigma ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 0.9894994 0.4675514 0.4527541 ## [2,] 0.4675514 0.9452644 0.4794808 ## [3,] 0.4527541 0.4794808 0.9498403 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1.846100 1.398628 1.327764 ## [2,] 1.398628 1.985164 1.430151 ## [3,] 1.327764 1.430151 1.922361 ## ## ## $delta ## [1] 0.7055608 0.2944392 ## ## $n ## [1] 1000 ## ## $gamma ## [,1] [,2] ## [1,] 0.9434294 0.05657056 ## [2,] 0.1355593 0.86444068 ## ## $mllk ## [1] 4295.975 8.5 Residuals Since the data was simulated, the true parameters are known and the validity of the estimates cam be checked. t(report$mu) - mu ## [,1] [,2] [,3] ## [1,] -0.02066811 -0.02533735 0.03496308 ## [2,] 0.10579193 0.01696329 0.06944256 report$sigma - sigma ## , , 1 ## ## [,1] [,2] [,3] ## [1,] -0.01050063 -0.03244858 -0.04724595 ## [2,] -0.03244858 -0.05473563 -0.02051921 ## [3,] -0.04724595 -0.02051921 -0.05015973 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] -0.1539005 -0.10137205 -0.17223560 ## [2,] -0.1013720 -0.01483646 -0.06984944 ## [3,] -0.1722356 -0.06984944 -0.07763930 report$gamma - gamma ## [,1] [,2] ## [1,] -0.006570559 0.006570559 ## [2,] -0.014440678 0.014440678 The parameter estimation was successful References Genz, A., Bretz, F., Miwa, T., Mi, X., &amp; Hothorn, T. (2021). Mvtnorm: Multivariate normal and t distributions. Retrieved from http://mvtnorm.R-forge.R-project.org "]]
