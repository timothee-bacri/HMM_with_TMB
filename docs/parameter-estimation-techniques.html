<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 Parameter estimation techniques | [ UNDER CONSTRUCTION ] A gentle tutorial of accelerated parameter and confidence interval estimation for Hidden Markov Models using Template Model Builder</title>
  <meta name="description" content="This accompanies the article published at [GITHUB LINK]." />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 Parameter estimation techniques | [ UNDER CONSTRUCTION ] A gentle tutorial of accelerated parameter and confidence interval estimation for Hidden Markov Models using Template Model Builder" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://github.com/timothee-bacri/HMM_with_TMB" />
  
  <meta property="og:description" content="This accompanies the article published at [GITHUB LINK]." />
  <meta name="github-repo" content="timothee-bacri/HMM_with_TMB" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Parameter estimation techniques | [ UNDER CONSTRUCTION ] A gentle tutorial of accelerated parameter and confidence interval estimation for Hidden Markov Models using Template Model Builder" />
  
  <meta name="twitter:description" content="This accompanies the article published at [GITHUB LINK]." />
  

<meta name="author" content="Timothée Bacri timothee.bacri@uib.no" />
<meta name="author" content="Jan Bulla jan.bulla@uib.no" />
<meta name="author" content="Geir Berentsen geir.berentsen@nhh.no" />
<meta name="author" content="Sondre Hølleland sondre.hoelleland@hi.no" />


<meta name="date" content="2021-07-11" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="principles-of-using-tmb-for-maximum-likelihood-estimation.html"/>
<link rel="next" href="using-tmb.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Accompaniment of A gentle tutorial of accelerated parameter and confidence interval estimation for Hidden Markov Models using Template Model Builder</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Summary</a></li>
<li class="chapter" data-level="1" data-path="state-inf.html"><a href="state-inf.html"><i class="fa fa-check"></i><b>1</b> State inference</a><ul>
<li class="chapter" data-level="1.1" data-path="state-inf.html"><a href="state-inf.html#prepare-the-model"><i class="fa fa-check"></i><b>1.1</b> Prepare the model</a></li>
<li class="chapter" data-level="1.2" data-path="state-inf.html"><a href="state-inf.html#setup"><i class="fa fa-check"></i><b>1.2</b> Setup</a><ul>
<li class="chapter" data-level="1.2.1" data-path="state-inf.html"><a href="state-inf.html#define-variables"><i class="fa fa-check"></i><b>1.2.1</b> Define variables</a></li>
<li class="chapter" data-level="1.2.2" data-path="state-inf.html"><a href="state-inf.html#emissionoutput-probabilities"><i class="fa fa-check"></i><b>1.2.2</b> Emission/output probabilities</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="state-inf.html"><a href="state-inf.html#log-forward"><i class="fa fa-check"></i><b>1.3</b> Log-forward probabilities</a></li>
<li class="chapter" data-level="1.4" data-path="state-inf.html"><a href="state-inf.html#log-backward"><i class="fa fa-check"></i><b>1.4</b> Log-backward probabilities</a></li>
<li class="chapter" data-level="1.5" data-path="state-inf.html"><a href="state-inf.html#local-decoding"><i class="fa fa-check"></i><b>1.5</b> Smoothing probabilities and local decoding</a></li>
<li class="chapter" data-level="1.6" data-path="state-inf.html"><a href="state-inf.html#forecast"><i class="fa fa-check"></i><b>1.6</b> Forecast, h-step-ahead-probabilities</a></li>
<li class="chapter" data-level="1.7" data-path="state-inf.html"><a href="state-inf.html#global-decoding"><i class="fa fa-check"></i><b>1.7</b> Global decoding using the Viterbi algorithm</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="principles-of-using-tmb-for-maximum-likelihood-estimation.html"><a href="principles-of-using-tmb-for-maximum-likelihood-estimation.html"><i class="fa fa-check"></i><b>2</b> Principles of using <code>TMB</code> for Maximum Likelihood Estimation</a><ul>
<li class="chapter" data-level="2.1" data-path="principles-of-using-tmb-for-maximum-likelihood-estimation.html"><a href="principles-of-using-tmb-for-maximum-likelihood-estimation.html#setting-up-tmb"><i class="fa fa-check"></i><b>2.1</b> Setting up <code>TMB</code></a></li>
<li class="chapter" data-level="2.2" data-path="principles-of-using-tmb-for-maximum-likelihood-estimation.html"><a href="principles-of-using-tmb-for-maximum-likelihood-estimation.html#getting-started-with-a-linear-regression"><i class="fa fa-check"></i><b>2.2</b> Getting started with a linear regression</a></li>
<li class="chapter" data-level="2.3" data-path="principles-of-using-tmb-for-maximum-likelihood-estimation.html"><a href="principles-of-using-tmb-for-maximum-likelihood-estimation.html#extending-the-c-negative-log-likelihood"><i class="fa fa-check"></i><b>2.3</b> Extending the <code>C++</code> negative log-likelihood</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html"><i class="fa fa-check"></i><b>3</b> Parameter estimation techniques</a><ul>
<li class="chapter" data-level="3.1" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html#negative-log-likelihood-in-tmb"><i class="fa fa-check"></i><b>3.1</b> Negative log-likelihood in <code>TMB</code></a></li>
<li class="chapter" data-level="3.2" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html#utility-functions"><i class="fa fa-check"></i><b>3.2</b> Utility functions</a><ul>
<li class="chapter" data-level="3.2.1" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html#in-tmb"><i class="fa fa-check"></i><b>3.2.1</b> In <code>TMB</code></a></li>
<li class="chapter" data-level="3.2.2" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html#in-r"><i class="fa fa-check"></i><b>3.2.2</b> In <code>R</code></a><ul>
<li class="chapter" data-level="3.2.2.1" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html#parameters"><i class="fa fa-check"></i><b>3.2.2.1</b> Parameters</a></li>
<li class="chapter" data-level="3.2.2.2" data-path="parameter-estimation-techniques.html"><a href="parameter-estimation-techniques.html#label-switching"><i class="fa fa-check"></i><b>3.2.2.2</b> Label switching</a></li>
</ul></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="using-tmb.html"><a href="using-tmb.html"><i class="fa fa-check"></i><b>4</b> Using TMB</a><ul>
<li class="chapter" data-level="4.1" data-path="using-tmb.html"><a href="using-tmb.html#likelihood-function"><i class="fa fa-check"></i><b>4.1</b> Likelihood function</a></li>
<li class="chapter" data-level="4.2" data-path="using-tmb.html"><a href="using-tmb.html#preparing-data-and-functions"><i class="fa fa-check"></i><b>4.2</b> Preparing data and functions</a></li>
<li class="chapter" data-level="4.3" data-path="using-tmb.html"><a href="using-tmb.html#modeling"><i class="fa fa-check"></i><b>4.3</b> Modeling</a></li>
<li class="chapter" data-level="4.4" data-path="using-tmb.html"><a href="using-tmb.html#nested-models"><i class="fa fa-check"></i><b>4.4</b> Nested models</a><ul>
<li class="chapter" data-level="4.4.1" data-path="using-tmb.html"><a href="using-tmb.html#principle"><i class="fa fa-check"></i><b>4.4.1</b> Principle</a></li>
<li class="chapter" data-level="4.4.2" data-path="using-tmb.html"><a href="using-tmb.html#limit"><i class="fa fa-check"></i><b>4.4.2</b> Limit</a></li>
<li class="chapter" data-level="4.4.3" data-path="using-tmb.html"><a href="using-tmb.html#parameter-equality-constraints"><i class="fa fa-check"></i><b>4.4.3</b> Parameter equality constraints</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="confidence-intervals.html"><a href="confidence-intervals.html"><i class="fa fa-check"></i><b>5</b> Confidence intervals</a><ul>
<li class="chapter" data-level="5.1" data-path="confidence-intervals.html"><a href="confidence-intervals.html#wald-type"><i class="fa fa-check"></i><b>5.1</b> Wald-type</a></li>
<li class="chapter" data-level="5.2" data-path="confidence-intervals.html"><a href="confidence-intervals.html#parametric-bootstrap"><i class="fa fa-check"></i><b>5.2</b> Parametric bootstrap</a><ul>
<li class="chapter" data-level="5.2.1" data-path="confidence-intervals.html"><a href="confidence-intervals.html#generating-data"><i class="fa fa-check"></i><b>5.2.1</b> Generating data</a></li>
<li class="chapter" data-level="5.2.2" data-path="confidence-intervals.html"><a href="confidence-intervals.html#bootstrap"><i class="fa fa-check"></i><b>5.2.2</b> Bootstrap</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="confidence-intervals.html"><a href="confidence-intervals.html#profiling-the-negative-log-likelihood"><i class="fa fa-check"></i><b>5.3</b> Profiling the negative log-likelihood</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="application-to-different-data-sets.html"><a href="application-to-different-data-sets.html"><i class="fa fa-check"></i><b>6</b> Application to different data sets</a><ul>
<li class="chapter" data-level="6.1" data-path="application-to-different-data-sets.html"><a href="application-to-different-data-sets.html#tyt-dataset"><i class="fa fa-check"></i><b>6.1</b> TYT dataset</a></li>
<li class="chapter" data-level="6.2" data-path="application-to-different-data-sets.html"><a href="application-to-different-data-sets.html#simulated-dataset"><i class="fa fa-check"></i><b>6.2</b> Simulated dataset</a></li>
<li class="chapter" data-level="6.3" data-path="application-to-different-data-sets.html"><a href="application-to-different-data-sets.html#lamb-data"><i class="fa fa-check"></i><b>6.3</b> Lamb data</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="github-directory-structure.html"><a href="github-directory-structure.html"><i class="fa fa-check"></i><b>7</b> GitHub directory structure</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">[ UNDER CONSTRUCTION ] A gentle tutorial of accelerated parameter and confidence interval estimation for Hidden Markov Models using Template Model Builder</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="parameter-estimation-techniques" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Parameter estimation techniques</h1>
<div id="negative-log-likelihood-in-tmb" class="section level2">
<h2><span class="header-section-number">3.1</span> Negative log-likelihood in <code>TMB</code></h2>
<p>The Poisson HMM negative log-likelihood function in R can be written the following way.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="parameter-estimation-techniques.html#cb34-1"></a><span class="pp">#include </span><span class="im">&lt;TMB.hpp&gt;</span></span>
<span id="cb34-2"><a href="parameter-estimation-techniques.html#cb34-2"></a><span class="pp">#include </span><span class="im">&quot;../functions/utils.cpp&quot;</span></span>
<span id="cb34-3"><a href="parameter-estimation-techniques.html#cb34-3"></a></span>
<span id="cb34-4"><a href="parameter-estimation-techniques.html#cb34-4"></a><span class="co">// Likelihood for a poisson hidden markov model. </span></span>
<span id="cb34-5"><a href="parameter-estimation-techniques.html#cb34-5"></a><span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb34-6"><a href="parameter-estimation-techniques.html#cb34-6"></a>Type objective_function&lt;Type&gt;::<span class="kw">operator</span>() ()</span>
<span id="cb34-7"><a href="parameter-estimation-techniques.html#cb34-7"></a>{</span>
<span id="cb34-8"><a href="parameter-estimation-techniques.html#cb34-8"></a>  </span>
<span id="cb34-9"><a href="parameter-estimation-techniques.html#cb34-9"></a>  <span class="co">// Data</span></span>
<span id="cb34-10"><a href="parameter-estimation-techniques.html#cb34-10"></a>  DATA_VECTOR(x);          <span class="co">// timeseries vector</span></span>
<span id="cb34-11"><a href="parameter-estimation-techniques.html#cb34-11"></a>  DATA_INTEGER(m);         <span class="co">// Number of states m</span></span>
<span id="cb34-12"><a href="parameter-estimation-techniques.html#cb34-12"></a>  </span>
<span id="cb34-13"><a href="parameter-estimation-techniques.html#cb34-13"></a>  <span class="co">// Parameters</span></span>
<span id="cb34-14"><a href="parameter-estimation-techniques.html#cb34-14"></a>  PARAMETER_VECTOR(tlambda);     <span class="co">// conditional log_lambdas&#39;s</span></span>
<span id="cb34-15"><a href="parameter-estimation-techniques.html#cb34-15"></a>  PARAMETER_VECTOR(tgamma);      <span class="co">// m(m-1) working parameters of TPM</span></span>
<span id="cb34-16"><a href="parameter-estimation-techniques.html#cb34-16"></a>  </span>
<span id="cb34-17"><a href="parameter-estimation-techniques.html#cb34-17"></a>  <span class="co">// Uncomment only when using a non-stationary distribution</span></span>
<span id="cb34-18"><a href="parameter-estimation-techniques.html#cb34-18"></a>  <span class="co">//PARAMETER_VECTOR(tdelta);    // transformed stationary distribution,</span></span>
<span id="cb34-19"><a href="parameter-estimation-techniques.html#cb34-19"></a></span>
<span id="cb34-20"><a href="parameter-estimation-techniques.html#cb34-20"></a>  <span class="co">// Transform working parameters to natural parameters:</span></span>
<span id="cb34-21"><a href="parameter-estimation-techniques.html#cb34-21"></a>  vector&lt;Type&gt; lambda = tlambda.exp();</span>
<span id="cb34-22"><a href="parameter-estimation-techniques.html#cb34-22"></a>  matrix&lt;Type&gt; gamma = Gamma_w2n(m, tgamma);</span>
<span id="cb34-23"><a href="parameter-estimation-techniques.html#cb34-23"></a>  </span>
<span id="cb34-24"><a href="parameter-estimation-techniques.html#cb34-24"></a>  <span class="co">// Construct stationary distribution</span></span>
<span id="cb34-25"><a href="parameter-estimation-techniques.html#cb34-25"></a>  vector&lt;Type&gt; delta = Stat_dist(m, gamma);</span>
<span id="cb34-26"><a href="parameter-estimation-techniques.html#cb34-26"></a>  <span class="co">// If using a non-stationary distribution, use this instead</span></span>
<span id="cb34-27"><a href="parameter-estimation-techniques.html#cb34-27"></a>  <span class="co">//vector&lt;Type&gt; delta = Delta_w2n(m, tdelta);</span></span>
<span id="cb34-28"><a href="parameter-estimation-techniques.html#cb34-28"></a>  </span>
<span id="cb34-29"><a href="parameter-estimation-techniques.html#cb34-29"></a>  <span class="co">// Get number of timesteps (n)</span></span>
<span id="cb34-30"><a href="parameter-estimation-techniques.html#cb34-30"></a>  <span class="dt">int</span> n = x.size();</span>
<span id="cb34-31"><a href="parameter-estimation-techniques.html#cb34-31"></a>  </span>
<span id="cb34-32"><a href="parameter-estimation-techniques.html#cb34-32"></a>  <span class="co">// Evaluate conditional distribution: Put conditional</span></span>
<span id="cb34-33"><a href="parameter-estimation-techniques.html#cb34-33"></a>  <span class="co">// probabilities of observed x in n times m matrix</span></span>
<span id="cb34-34"><a href="parameter-estimation-techniques.html#cb34-34"></a>  <span class="co">// (one column for each state, one row for each datapoint):</span></span>
<span id="cb34-35"><a href="parameter-estimation-techniques.html#cb34-35"></a>  matrix&lt;Type&gt; emission_probs(n, m);</span>
<span id="cb34-36"><a href="parameter-estimation-techniques.html#cb34-36"></a>  matrix&lt;Type&gt; row1vec(<span class="dv">1</span>, m);</span>
<span id="cb34-37"><a href="parameter-estimation-techniques.html#cb34-37"></a>  row1vec.setOnes();</span>
<span id="cb34-38"><a href="parameter-estimation-techniques.html#cb34-38"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</span>
<span id="cb34-39"><a href="parameter-estimation-techniques.html#cb34-39"></a>    <span class="cf">if</span> (x[i] != x[i]) { <span class="co">// f != f returns true if and only if f is NaN. </span></span>
<span id="cb34-40"><a href="parameter-estimation-techniques.html#cb34-40"></a>      <span class="co">// Replace missing values (NA in R, NaN in C++) with 1</span></span>
<span id="cb34-41"><a href="parameter-estimation-techniques.html#cb34-41"></a>      emission_probs.row(i) = row1vec;</span>
<span id="cb34-42"><a href="parameter-estimation-techniques.html#cb34-42"></a>    }</span>
<span id="cb34-43"><a href="parameter-estimation-techniques.html#cb34-43"></a>    <span class="cf">else</span> {</span>
<span id="cb34-44"><a href="parameter-estimation-techniques.html#cb34-44"></a>      emission_probs.row(i) = dpois(x[i], lambda, <span class="kw">false</span>);</span>
<span id="cb34-45"><a href="parameter-estimation-techniques.html#cb34-45"></a>    }</span>
<span id="cb34-46"><a href="parameter-estimation-techniques.html#cb34-46"></a>  }</span>
<span id="cb34-47"><a href="parameter-estimation-techniques.html#cb34-47"></a></span>
<span id="cb34-48"><a href="parameter-estimation-techniques.html#cb34-48"></a>  <span class="co">// Corresponds to Zucchini&#39;s book page 333</span></span>
<span id="cb34-49"><a href="parameter-estimation-techniques.html#cb34-49"></a>  matrix&lt;Type&gt; foo, P;</span>
<span id="cb34-50"><a href="parameter-estimation-techniques.html#cb34-50"></a>  Type mllk, sumfoo, lscale;</span>
<span id="cb34-51"><a href="parameter-estimation-techniques.html#cb34-51"></a>  </span>
<span id="cb34-52"><a href="parameter-estimation-techniques.html#cb34-52"></a>  <span class="cf">if</span> (m == <span class="dv">1</span>) {</span>
<span id="cb34-53"><a href="parameter-estimation-techniques.html#cb34-53"></a>    mllk = - emission_probs.col(<span class="dv">0</span>).array().log().sum();</span>
<span id="cb34-54"><a href="parameter-estimation-techniques.html#cb34-54"></a>    </span>
<span id="cb34-55"><a href="parameter-estimation-techniques.html#cb34-55"></a>    <span class="co">// Use adreport on variables we are interested in:</span></span>
<span id="cb34-56"><a href="parameter-estimation-techniques.html#cb34-56"></a>    ADREPORT(lambda);</span>
<span id="cb34-57"><a href="parameter-estimation-techniques.html#cb34-57"></a>    ADREPORT(gamma);</span>
<span id="cb34-58"><a href="parameter-estimation-techniques.html#cb34-58"></a>    ADREPORT(delta);</span>
<span id="cb34-59"><a href="parameter-estimation-techniques.html#cb34-59"></a>    </span>
<span id="cb34-60"><a href="parameter-estimation-techniques.html#cb34-60"></a>    <span class="co">// Things we need for local decoding</span></span>
<span id="cb34-61"><a href="parameter-estimation-techniques.html#cb34-61"></a>    REPORT(lambda);</span>
<span id="cb34-62"><a href="parameter-estimation-techniques.html#cb34-62"></a>    REPORT(gamma);</span>
<span id="cb34-63"><a href="parameter-estimation-techniques.html#cb34-63"></a>    REPORT(delta);</span>
<span id="cb34-64"><a href="parameter-estimation-techniques.html#cb34-64"></a>    </span>
<span id="cb34-65"><a href="parameter-estimation-techniques.html#cb34-65"></a>    <span class="cf">return</span> mllk;</span>
<span id="cb34-66"><a href="parameter-estimation-techniques.html#cb34-66"></a>  }</span>
<span id="cb34-67"><a href="parameter-estimation-techniques.html#cb34-67"></a>  foo = (delta * vector&lt;Type&gt;(emission_probs.row(<span class="dv">0</span>))).matrix();</span>
<span id="cb34-68"><a href="parameter-estimation-techniques.html#cb34-68"></a>  sumfoo = foo.sum();</span>
<span id="cb34-69"><a href="parameter-estimation-techniques.html#cb34-69"></a>  lscale = log(sumfoo);</span>
<span id="cb34-70"><a href="parameter-estimation-techniques.html#cb34-70"></a>  foo.transposeInPlace();</span>
<span id="cb34-71"><a href="parameter-estimation-techniques.html#cb34-71"></a>  foo /= sumfoo;</span>
<span id="cb34-72"><a href="parameter-estimation-techniques.html#cb34-72"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i++) {</span>
<span id="cb34-73"><a href="parameter-estimation-techniques.html#cb34-73"></a>    P = emission_probs.row(i - <span class="dv">1</span>);</span>
<span id="cb34-74"><a href="parameter-estimation-techniques.html#cb34-74"></a>    foo = ((foo * gamma).array() * P.array()).matrix();</span>
<span id="cb34-75"><a href="parameter-estimation-techniques.html#cb34-75"></a>    sumfoo = foo.sum();</span>
<span id="cb34-76"><a href="parameter-estimation-techniques.html#cb34-76"></a>    lscale += log(sumfoo);</span>
<span id="cb34-77"><a href="parameter-estimation-techniques.html#cb34-77"></a>    foo /= sumfoo;</span>
<span id="cb34-78"><a href="parameter-estimation-techniques.html#cb34-78"></a>  }</span>
<span id="cb34-79"><a href="parameter-estimation-techniques.html#cb34-79"></a>  mllk = -lscale;</span>
<span id="cb34-80"><a href="parameter-estimation-techniques.html#cb34-80"></a>  </span>
<span id="cb34-81"><a href="parameter-estimation-techniques.html#cb34-81"></a>  <span class="co">// Use adreport on variables for which we want standard errors</span></span>
<span id="cb34-82"><a href="parameter-estimation-techniques.html#cb34-82"></a>  ADREPORT(lambda);</span>
<span id="cb34-83"><a href="parameter-estimation-techniques.html#cb34-83"></a>  ADREPORT(gamma);</span>
<span id="cb34-84"><a href="parameter-estimation-techniques.html#cb34-84"></a>  ADREPORT(delta);</span>
<span id="cb34-85"><a href="parameter-estimation-techniques.html#cb34-85"></a>  </span>
<span id="cb34-86"><a href="parameter-estimation-techniques.html#cb34-86"></a>  <span class="co">// Variables we need for local decoding and in a convenient format</span></span>
<span id="cb34-87"><a href="parameter-estimation-techniques.html#cb34-87"></a>  REPORT(lambda);</span>
<span id="cb34-88"><a href="parameter-estimation-techniques.html#cb34-88"></a>  REPORT(gamma);</span>
<span id="cb34-89"><a href="parameter-estimation-techniques.html#cb34-89"></a>  REPORT(delta);</span>
<span id="cb34-90"><a href="parameter-estimation-techniques.html#cb34-90"></a>  REPORT(n);</span>
<span id="cb34-91"><a href="parameter-estimation-techniques.html#cb34-91"></a>  REPORT(emission_probs);</span>
<span id="cb34-92"><a href="parameter-estimation-techniques.html#cb34-92"></a>  REPORT(mllk);</span>
<span id="cb34-93"><a href="parameter-estimation-techniques.html#cb34-93"></a>  </span>
<span id="cb34-94"><a href="parameter-estimation-techniques.html#cb34-94"></a>  <span class="cf">return</span> mllk;</span>
<span id="cb34-95"><a href="parameter-estimation-techniques.html#cb34-95"></a>}</span></code></pre></div>
<p>The case where <span class="math inline">\(m = 1\)</span> doesn’t involve a hidden state, and thus is a Poisson regression instead of a Poisson HMM.
Nonetheless, <code>TMB</code> also accelerates its estimation and may be useful to the reader.</p>
</div>
<div id="utility-functions" class="section level2">
<h2><span class="header-section-number">3.2</span> Utility functions</h2>
<div id="in-tmb" class="section level3">
<h3><span class="header-section-number">3.2.1</span> In <code>TMB</code></h3>
<p>Defining the negative log-likelihood function requires transforming the working parameters into their natural form.
We define the function <code>gamma.w2n</code> to perform this transformation.</p>
<p><code>stat_dist</code> handles computing the stationary distribution, although <code>delta.w2n</code> can be used if a non-stationary distribution is provided.</p>
<p>They are defined</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="parameter-estimation-techniques.html#cb35-1"></a><span class="co">// Function transforming working parameters in initial distribution</span></span>
<span id="cb35-2"><a href="parameter-estimation-techniques.html#cb35-2"></a><span class="co">// to natural parameters</span></span>
<span id="cb35-3"><a href="parameter-estimation-techniques.html#cb35-3"></a><span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb35-4"><a href="parameter-estimation-techniques.html#cb35-4"></a>vector&lt;Type&gt; Delta_w2n(<span class="dt">int</span> m, vector&lt;Type&gt; tdelta) {</span>
<span id="cb35-5"><a href="parameter-estimation-techniques.html#cb35-5"></a></span>
<span id="cb35-6"><a href="parameter-estimation-techniques.html#cb35-6"></a>  vector&lt;Type&gt; delta(m);</span>
<span id="cb35-7"><a href="parameter-estimation-techniques.html#cb35-7"></a>  vector&lt;Type&gt; foo(m);</span>
<span id="cb35-8"><a href="parameter-estimation-techniques.html#cb35-8"></a>  </span>
<span id="cb35-9"><a href="parameter-estimation-techniques.html#cb35-9"></a>  <span class="cf">if</span> (m == <span class="dv">1</span>)</span>
<span id="cb35-10"><a href="parameter-estimation-techniques.html#cb35-10"></a>    <span class="cf">return</span> Type(<span class="dv">1</span>);</span>
<span id="cb35-11"><a href="parameter-estimation-techniques.html#cb35-11"></a>  </span>
<span id="cb35-12"><a href="parameter-estimation-techniques.html#cb35-12"></a>  <span class="co">// set first element to one.</span></span>
<span id="cb35-13"><a href="parameter-estimation-techniques.html#cb35-13"></a>  <span class="co">// Fill in the last m - 1 elements with working parameters</span></span>
<span id="cb35-14"><a href="parameter-estimation-techniques.html#cb35-14"></a>  <span class="co">// and take exponential</span></span>
<span id="cb35-15"><a href="parameter-estimation-techniques.html#cb35-15"></a>  foo &lt;&lt; Type(<span class="dv">1</span>), tdelta.exp();</span>
<span id="cb35-16"><a href="parameter-estimation-techniques.html#cb35-16"></a></span>
<span id="cb35-17"><a href="parameter-estimation-techniques.html#cb35-17"></a>  <span class="co">// normalize</span></span>
<span id="cb35-18"><a href="parameter-estimation-techniques.html#cb35-18"></a>  delta = foo / foo.sum();</span>
<span id="cb35-19"><a href="parameter-estimation-techniques.html#cb35-19"></a></span>
<span id="cb35-20"><a href="parameter-estimation-techniques.html#cb35-20"></a>  <span class="cf">return</span> delta;</span>
<span id="cb35-21"><a href="parameter-estimation-techniques.html#cb35-21"></a>}</span>
<span id="cb35-22"><a href="parameter-estimation-techniques.html#cb35-22"></a></span>
<span id="cb35-23"><a href="parameter-estimation-techniques.html#cb35-23"></a><span class="co">// Function transforming the working parameters in TPM to</span></span>
<span id="cb35-24"><a href="parameter-estimation-techniques.html#cb35-24"></a><span class="co">// natural parameters (w2n)</span></span>
<span id="cb35-25"><a href="parameter-estimation-techniques.html#cb35-25"></a><span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb35-26"><a href="parameter-estimation-techniques.html#cb35-26"></a>matrix&lt;Type&gt; Gamma_w2n(<span class="dt">int</span> m, vector&lt;Type&gt; tgamma) {</span>
<span id="cb35-27"><a href="parameter-estimation-techniques.html#cb35-27"></a></span>
<span id="cb35-28"><a href="parameter-estimation-techniques.html#cb35-28"></a>  <span class="co">// Construct m x m identity matrix</span></span>
<span id="cb35-29"><a href="parameter-estimation-techniques.html#cb35-29"></a>  matrix&lt;Type&gt; gamma(m, m);</span>
<span id="cb35-30"><a href="parameter-estimation-techniques.html#cb35-30"></a>  gamma.setIdentity();</span>
<span id="cb35-31"><a href="parameter-estimation-techniques.html#cb35-31"></a>  </span>
<span id="cb35-32"><a href="parameter-estimation-techniques.html#cb35-32"></a>  <span class="cf">if</span> (m == <span class="dv">1</span>)</span>
<span id="cb35-33"><a href="parameter-estimation-techniques.html#cb35-33"></a>    <span class="cf">return</span> gamma;</span>
<span id="cb35-34"><a href="parameter-estimation-techniques.html#cb35-34"></a></span>
<span id="cb35-35"><a href="parameter-estimation-techniques.html#cb35-35"></a>  <span class="co">// Fill offdiagonal elements with working parameters column-wise:</span></span>
<span id="cb35-36"><a href="parameter-estimation-techniques.html#cb35-36"></a>  <span class="dt">int</span> idx = <span class="dv">0</span>;</span>
<span id="cb35-37"><a href="parameter-estimation-techniques.html#cb35-37"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++){</span>
<span id="cb35-38"><a href="parameter-estimation-techniques.html#cb35-38"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; j++){</span>
<span id="cb35-39"><a href="parameter-estimation-techniques.html#cb35-39"></a>      <span class="cf">if</span> (j != i){</span>
<span id="cb35-40"><a href="parameter-estimation-techniques.html#cb35-40"></a>        <span class="co">// Fill gamma according to mapping and take exponential</span></span>
<span id="cb35-41"><a href="parameter-estimation-techniques.html#cb35-41"></a>        gamma(j, i) = tgamma.exp()(idx);</span>
<span id="cb35-42"><a href="parameter-estimation-techniques.html#cb35-42"></a>        idx++;</span>
<span id="cb35-43"><a href="parameter-estimation-techniques.html#cb35-43"></a>      }</span>
<span id="cb35-44"><a href="parameter-estimation-techniques.html#cb35-44"></a>    }</span>
<span id="cb35-45"><a href="parameter-estimation-techniques.html#cb35-45"></a>  }</span>
<span id="cb35-46"><a href="parameter-estimation-techniques.html#cb35-46"></a>  <span class="co">// Normalize each row:</span></span>
<span id="cb35-47"><a href="parameter-estimation-techniques.html#cb35-47"></a>  vector&lt;Type&gt; cs = gamma.rowwise().sum();</span>
<span id="cb35-48"><a href="parameter-estimation-techniques.html#cb35-48"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; m; i++) gamma.row(i) /= cs[i];</span>
<span id="cb35-49"><a href="parameter-estimation-techniques.html#cb35-49"></a></span>
<span id="cb35-50"><a href="parameter-estimation-techniques.html#cb35-50"></a>  <span class="cf">return</span> gamma;</span>
<span id="cb35-51"><a href="parameter-estimation-techniques.html#cb35-51"></a>}</span>
<span id="cb35-52"><a href="parameter-estimation-techniques.html#cb35-52"></a></span>
<span id="cb35-53"><a href="parameter-estimation-techniques.html#cb35-53"></a><span class="co">// Function computing the stationary distribution of a Markov chain</span></span>
<span id="cb35-54"><a href="parameter-estimation-techniques.html#cb35-54"></a><span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb35-55"><a href="parameter-estimation-techniques.html#cb35-55"></a>vector&lt;Type&gt; Stat_dist(<span class="dt">int</span> m, matrix&lt;Type&gt; gamma) {</span>
<span id="cb35-56"><a href="parameter-estimation-techniques.html#cb35-56"></a>  </span>
<span id="cb35-57"><a href="parameter-estimation-techniques.html#cb35-57"></a>  <span class="co">// Construct stationary distribution</span></span>
<span id="cb35-58"><a href="parameter-estimation-techniques.html#cb35-58"></a>  matrix&lt;Type&gt; I(m, m);</span>
<span id="cb35-59"><a href="parameter-estimation-techniques.html#cb35-59"></a>  matrix&lt;Type&gt; U(m, m);</span>
<span id="cb35-60"><a href="parameter-estimation-techniques.html#cb35-60"></a>  matrix&lt;Type&gt; row1vec(<span class="dv">1</span>, m);</span>
<span id="cb35-61"><a href="parameter-estimation-techniques.html#cb35-61"></a>  U = U.setOnes();</span>
<span id="cb35-62"><a href="parameter-estimation-techniques.html#cb35-62"></a>  I = I.setIdentity();</span>
<span id="cb35-63"><a href="parameter-estimation-techniques.html#cb35-63"></a>  row1vec.setOnes();</span>
<span id="cb35-64"><a href="parameter-estimation-techniques.html#cb35-64"></a>  matrix&lt;Type&gt; A =  I - gamma + U;</span>
<span id="cb35-65"><a href="parameter-estimation-techniques.html#cb35-65"></a>  matrix&lt;Type&gt; Ainv = A.inverse();</span>
<span id="cb35-66"><a href="parameter-estimation-techniques.html#cb35-66"></a>  matrix&lt;Type&gt; deltamat = row1vec * Ainv;</span>
<span id="cb35-67"><a href="parameter-estimation-techniques.html#cb35-67"></a>  vector&lt;Type&gt; delta = deltamat.row(<span class="dv">0</span>);</span>
<span id="cb35-68"><a href="parameter-estimation-techniques.html#cb35-68"></a>  </span>
<span id="cb35-69"><a href="parameter-estimation-techniques.html#cb35-69"></a>  <span class="cf">return</span> delta;</span>
<span id="cb35-70"><a href="parameter-estimation-techniques.html#cb35-70"></a>}</span></code></pre></div>
<p>Transforming the Poisson means into their natural form can be done simply with the <code>exp</code> function and doesn’t require a dedicated function.</p>
</div>
<div id="in-r" class="section level3">
<h3><span class="header-section-number">3.2.2</span> In <code>R</code></h3>
<div id="parameters" class="section level4">
<h4><span class="header-section-number">3.2.2.1</span> Parameters</h4>
<p>While <code>TMB</code> requires functions to transform working parameters to their natural form, pre-processing in <code>R</code> requires the opposite.</p>
<p>Functions to achieve this are available in <span class="citation">(Zucchini, MacDonald, and Langrock <a href="#ref-zucchini" role="doc-biblioref">2016</a>, ~51)</span> and are displayed here for convenience.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="parameter-estimation-techniques.html#cb36-1"></a><span class="co"># Transform Poisson natural parameters to working parameters</span></span>
<span id="cb36-2"><a href="parameter-estimation-techniques.html#cb36-2"></a>pois.HMM.pn2pw &lt;-<span class="st"> </span><span class="cf">function</span>(m, lambda, gamma, <span class="dt">delta =</span> <span class="ot">NULL</span>,</span>
<span id="cb36-3"><a href="parameter-estimation-techniques.html#cb36-3"></a>                           <span class="dt">stationary =</span> <span class="ot">TRUE</span>) {</span>
<span id="cb36-4"><a href="parameter-estimation-techniques.html#cb36-4"></a>  tlambda &lt;-<span class="st"> </span><span class="kw">log</span>(lambda)</span>
<span id="cb36-5"><a href="parameter-estimation-techniques.html#cb36-5"></a>  foo &lt;-<span class="st"> </span><span class="kw">log</span>(gamma <span class="op">/</span><span class="st"> </span><span class="kw">diag</span>(gamma))</span>
<span id="cb36-6"><a href="parameter-estimation-techniques.html#cb36-6"></a>  tgamma &lt;-<span class="st"> </span><span class="kw">as.vector</span>(foo[<span class="op">!</span><span class="kw">diag</span>(m)])</span>
<span id="cb36-7"><a href="parameter-estimation-techniques.html#cb36-7"></a>  <span class="cf">if</span> (stationary) {</span>
<span id="cb36-8"><a href="parameter-estimation-techniques.html#cb36-8"></a>    <span class="co"># If tdelta is set to NULL and returned in the list,</span></span>
<span id="cb36-9"><a href="parameter-estimation-techniques.html#cb36-9"></a>    <span class="co"># it will cause issues when optimizing with TMB</span></span>
<span id="cb36-10"><a href="parameter-estimation-techniques.html#cb36-10"></a>    <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">tlambda =</span> tlambda, <span class="dt">tgamma =</span> tgamma))</span>
<span id="cb36-11"><a href="parameter-estimation-techniques.html#cb36-11"></a>  } <span class="cf">else</span> {</span>
<span id="cb36-12"><a href="parameter-estimation-techniques.html#cb36-12"></a>    tdelta &lt;-<span class="st"> </span><span class="kw">log</span>(delta[<span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">/</span><span class="st"> </span>delta[<span class="dv">1</span>])</span>
<span id="cb36-13"><a href="parameter-estimation-techniques.html#cb36-13"></a>    <span class="co"># TMB requires a list</span></span>
<span id="cb36-14"><a href="parameter-estimation-techniques.html#cb36-14"></a>    <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">tlambda =</span> tlambda, <span class="dt">tgamma =</span> tgamma, <span class="dt">tdelta =</span> tdelta))</span>
<span id="cb36-15"><a href="parameter-estimation-techniques.html#cb36-15"></a>  }</span>
<span id="cb36-16"><a href="parameter-estimation-techniques.html#cb36-16"></a>}</span></code></pre></div>
<p>This can be broken down into sub-functions if necessary. For the <span class="math inline">\(\gamma\)</span> part, we introduce <code>gamma.n2w</code> below.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="parameter-estimation-techniques.html#cb37-1"></a>gamma.n2w &lt;-<span class="st"> </span><span class="cf">function</span>(m, gamma){</span>
<span id="cb37-2"><a href="parameter-estimation-techniques.html#cb37-2"></a>  foo &lt;-<span class="st"> </span><span class="kw">log</span>(gamma <span class="op">/</span><span class="st"> </span><span class="kw">diag</span>(gamma))</span>
<span id="cb37-3"><a href="parameter-estimation-techniques.html#cb37-3"></a>  tgamma &lt;-<span class="st"> </span><span class="kw">as.vector</span>(foo[<span class="op">!</span><span class="kw">diag</span>(m)])</span>
<span id="cb37-4"><a href="parameter-estimation-techniques.html#cb37-4"></a>  <span class="kw">return</span>(tgamma)</span>
<span id="cb37-5"><a href="parameter-estimation-techniques.html#cb37-5"></a>}</span></code></pre></div>
<p>In the case where a non-stationary distribution is specified, transforming <span class="math inline">\({\boldsymbol\delta}\)</span> is necessary. For this we use the <code>delta.n2w</code> function.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="parameter-estimation-techniques.html#cb38-1"></a><span class="co"># Function to transform natural parameters to working</span></span>
<span id="cb38-2"><a href="parameter-estimation-techniques.html#cb38-2"></a>delta.n2w &lt;-<span class="st"> </span><span class="cf">function</span>(m, delta){</span>
<span id="cb38-3"><a href="parameter-estimation-techniques.html#cb38-3"></a>  tdelta &lt;-<span class="st"> </span><span class="kw">log</span>(delta[<span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">/</span><span class="st"> </span>delta[<span class="dv">1</span>])</span>
<span id="cb38-4"><a href="parameter-estimation-techniques.html#cb38-4"></a>  <span class="kw">return</span>(tdelta) </span>
<span id="cb38-5"><a href="parameter-estimation-techniques.html#cb38-5"></a>}</span></code></pre></div>
<p>When assuming a stationary distribution, computing it can be done via the following <code>stat.dist</code> function.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="parameter-estimation-techniques.html#cb39-1"></a><span class="co"># Compute the stationary distribution of a Markov chain</span></span>
<span id="cb39-2"><a href="parameter-estimation-techniques.html#cb39-2"></a><span class="co"># with transition probability gamma</span></span>
<span id="cb39-3"><a href="parameter-estimation-techniques.html#cb39-3"></a>stat.dist &lt;-<span class="st"> </span><span class="cf">function</span>(gamma) {</span>
<span id="cb39-4"><a href="parameter-estimation-techniques.html#cb39-4"></a>  m &lt;-<span class="st"> </span><span class="kw">nrow</span>(gamma)</span>
<span id="cb39-5"><a href="parameter-estimation-techniques.html#cb39-5"></a>  <span class="kw">return</span>(<span class="kw">solve</span>(<span class="kw">t</span>(<span class="kw">diag</span>(m) <span class="op">-</span><span class="st"> </span>gamma <span class="op">+</span><span class="st"> </span><span class="dv">1</span>), <span class="kw">rep</span>(<span class="dv">1</span>, m)))</span>
<span id="cb39-6"><a href="parameter-estimation-techniques.html#cb39-6"></a>}</span></code></pre></div>
</div>
<div id="label-switching" class="section level4">
<h4><span class="header-section-number">3.2.2.2</span> Label switching</h4>
<p>As the model gets estimated each time, we do not impose by default an order for the states. This can lead to the label switching problem, where states aren’t ordered the same way in each model.
The issue can be relevant when comparing results of different optimizers, initial parameters, or classes of models.</p>
<p>To address the problem, we reorder the states by ascending Poisson means.
Sorting the means is direct, however re-ordering the TPM is not as straightforward.
To do so, we take the permutations of the states given by the sorted Poisson means, and permute each row index and column index to its new value.
A function to achieve this is named <code>pois.HMM.label.order</code> and presented below.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="parameter-estimation-techniques.html#cb40-1"></a><span class="co"># Relabel states by increasing Poisson means</span></span>
<span id="cb40-2"><a href="parameter-estimation-techniques.html#cb40-2"></a>pois.HMM.label.order &lt;-<span class="st"> </span><span class="cf">function</span>(m, lambda, gamma, <span class="dt">delta =</span> <span class="ot">NULL</span>, <span class="dt">lambda_std_error =</span> <span class="ot">NULL</span>, <span class="dt">gamma_std_error =</span> <span class="ot">NULL</span>, <span class="dt">delta_std_error =</span> <span class="ot">NULL</span>) {</span>
<span id="cb40-3"><a href="parameter-estimation-techniques.html#cb40-3"></a>  <span class="co"># gamma_vector_indices is used to calculate the indices of the reordered TPM gamma as a vector</span></span>
<span id="cb40-4"><a href="parameter-estimation-techniques.html#cb40-4"></a>  <span class="co"># for reordering the rows of the complete CI data.frame used for the article.</span></span>
<span id="cb40-5"><a href="parameter-estimation-techniques.html#cb40-5"></a>  gamma_vector_indices &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>(m <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)</span>
<span id="cb40-6"><a href="parameter-estimation-techniques.html#cb40-6"></a>  gamma_vector_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(gamma_vector_indices, <span class="dt">nrow =</span> m, <span class="dt">ncol =</span> m)</span>
<span id="cb40-7"><a href="parameter-estimation-techniques.html#cb40-7"></a>  ordered_gamma_vector_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> m, <span class="dt">ncol =</span> m)</span>
<span id="cb40-8"><a href="parameter-estimation-techniques.html#cb40-8"></a>  </span>
<span id="cb40-9"><a href="parameter-estimation-techniques.html#cb40-9"></a>  <span class="co"># Get the indexes of the sorted states</span></span>
<span id="cb40-10"><a href="parameter-estimation-techniques.html#cb40-10"></a>  <span class="co"># according to ascending lambda</span></span>
<span id="cb40-11"><a href="parameter-estimation-techniques.html#cb40-11"></a>  <span class="co"># sorted_lambda contains the permutations needed</span></span>
<span id="cb40-12"><a href="parameter-estimation-techniques.html#cb40-12"></a>  ordered_lambda_indices &lt;-<span class="st"> </span><span class="kw">sort</span>(lambda, <span class="dt">index.return =</span> <span class="ot">TRUE</span>)<span class="op">$</span>ix</span>
<span id="cb40-13"><a href="parameter-estimation-techniques.html#cb40-13"></a>  ordered_lambda &lt;-<span class="st"> </span>lambda[ordered_lambda_indices]</span>
<span id="cb40-14"><a href="parameter-estimation-techniques.html#cb40-14"></a>  <span class="co"># Reorder the TPM according to the switched states</span></span>
<span id="cb40-15"><a href="parameter-estimation-techniques.html#cb40-15"></a>  <span class="co"># in the sorted lambda</span></span>
<span id="cb40-16"><a href="parameter-estimation-techniques.html#cb40-16"></a>  ordered_gamma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> m, <span class="dt">ncol =</span> m)</span>
<span id="cb40-17"><a href="parameter-estimation-techniques.html#cb40-17"></a>  <span class="cf">for</span> (col <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {</span>
<span id="cb40-18"><a href="parameter-estimation-techniques.html#cb40-18"></a>    new_col &lt;-<span class="st"> </span><span class="kw">which</span>(ordered_lambda_indices <span class="op">==</span><span class="st"> </span>col)</span>
<span id="cb40-19"><a href="parameter-estimation-techniques.html#cb40-19"></a>    <span class="cf">for</span> (row <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {</span>
<span id="cb40-20"><a href="parameter-estimation-techniques.html#cb40-20"></a>      new_row &lt;-<span class="st"> </span><span class="kw">which</span>(ordered_lambda_indices <span class="op">==</span><span class="st"> </span>row)</span>
<span id="cb40-21"><a href="parameter-estimation-techniques.html#cb40-21"></a>      ordered_gamma[row, col] &lt;-<span class="st"> </span>gamma[new_row, new_col]</span>
<span id="cb40-22"><a href="parameter-estimation-techniques.html#cb40-22"></a>      </span>
<span id="cb40-23"><a href="parameter-estimation-techniques.html#cb40-23"></a>      <span class="co"># Reorder the vector TPM</span></span>
<span id="cb40-24"><a href="parameter-estimation-techniques.html#cb40-24"></a>      ordered_gamma_vector_matrix[row, col] &lt;-<span class="st"> </span>gamma_vector_matrix[new_row, new_col]</span>
<span id="cb40-25"><a href="parameter-estimation-techniques.html#cb40-25"></a>    }</span>
<span id="cb40-26"><a href="parameter-estimation-techniques.html#cb40-26"></a>  }</span>
<span id="cb40-27"><a href="parameter-estimation-techniques.html#cb40-27"></a>  <span class="co"># Same for the TPM&#39;s standard errors</span></span>
<span id="cb40-28"><a href="parameter-estimation-techniques.html#cb40-28"></a>  ordered_gamma_std_error &lt;-<span class="st"> </span><span class="ot">NULL</span></span>
<span id="cb40-29"><a href="parameter-estimation-techniques.html#cb40-29"></a>  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(gamma_std_error)) {</span>
<span id="cb40-30"><a href="parameter-estimation-techniques.html#cb40-30"></a>    ordered_gamma_std_error &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> m, <span class="dt">ncol =</span> m)</span>
<span id="cb40-31"><a href="parameter-estimation-techniques.html#cb40-31"></a>    <span class="cf">for</span> (col <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {</span>
<span id="cb40-32"><a href="parameter-estimation-techniques.html#cb40-32"></a>      new_col &lt;-<span class="st"> </span><span class="kw">which</span>(ordered_lambda_indices <span class="op">==</span><span class="st"> </span>col)</span>
<span id="cb40-33"><a href="parameter-estimation-techniques.html#cb40-33"></a>      <span class="cf">for</span> (row <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {</span>
<span id="cb40-34"><a href="parameter-estimation-techniques.html#cb40-34"></a>        new_row &lt;-<span class="st"> </span><span class="kw">which</span>(ordered_lambda_indices <span class="op">==</span><span class="st"> </span>row)</span>
<span id="cb40-35"><a href="parameter-estimation-techniques.html#cb40-35"></a>        ordered_gamma_std_error[row, col] &lt;-<span class="st"> </span>gamma_std_error[new_row, new_col]</span>
<span id="cb40-36"><a href="parameter-estimation-techniques.html#cb40-36"></a>      }</span>
<span id="cb40-37"><a href="parameter-estimation-techniques.html#cb40-37"></a>    }</span>
<span id="cb40-38"><a href="parameter-estimation-techniques.html#cb40-38"></a>  }</span>
<span id="cb40-39"><a href="parameter-estimation-techniques.html#cb40-39"></a>  </span>
<span id="cb40-40"><a href="parameter-estimation-techniques.html#cb40-40"></a>  <span class="co"># Reorder the stationary distribution if it is provided</span></span>
<span id="cb40-41"><a href="parameter-estimation-techniques.html#cb40-41"></a>  <span class="co"># Generate it otherwise</span></span>
<span id="cb40-42"><a href="parameter-estimation-techniques.html#cb40-42"></a>  <span class="cf">if</span> (<span class="kw">is.null</span>(delta)) {</span>
<span id="cb40-43"><a href="parameter-estimation-techniques.html#cb40-43"></a>    ordered_delta &lt;-<span class="st"> </span><span class="kw">stat.dist</span>(ordered_gamma)</span>
<span id="cb40-44"><a href="parameter-estimation-techniques.html#cb40-44"></a>  } <span class="cf">else</span> {</span>
<span id="cb40-45"><a href="parameter-estimation-techniques.html#cb40-45"></a>    ordered_delta &lt;-<span class="st"> </span>delta[ordered_lambda_indices]</span>
<span id="cb40-46"><a href="parameter-estimation-techniques.html#cb40-46"></a>  }</span>
<span id="cb40-47"><a href="parameter-estimation-techniques.html#cb40-47"></a>  <span class="co"># Reorder the standard errors</span></span>
<span id="cb40-48"><a href="parameter-estimation-techniques.html#cb40-48"></a>  ordered_lambda_std_error &lt;-<span class="st"> </span>lambda_std_error[ordered_lambda_indices]</span>
<span id="cb40-49"><a href="parameter-estimation-techniques.html#cb40-49"></a>  ordered_delta_std_error &lt;-<span class="st"> </span>delta_std_error[ordered_lambda_indices]</span>
<span id="cb40-50"><a href="parameter-estimation-techniques.html#cb40-50"></a>  </span>
<span id="cb40-51"><a href="parameter-estimation-techniques.html#cb40-51"></a>  <span class="co"># The vector is assumed filled column-wise instead of row-wise, because column-wise is the default way R handles matrix to vector conversion.</span></span>
<span id="cb40-52"><a href="parameter-estimation-techniques.html#cb40-52"></a>  <span class="co"># Change to row-wise if needed by replacing ordered_gamma_vector_matrix with t(ordered_gamma_vector_matrix), or add byrow=TRUE to &quot;ordered_gamma_vector_matrix &lt;- matrix(0, nrow = m, ncol = m)&quot;</span></span>
<span id="cb40-53"><a href="parameter-estimation-techniques.html#cb40-53"></a>  <span class="co"># We don&#39;t use it in case there is a bug, but it makes logical sense that it should work</span></span>
<span id="cb40-54"><a href="parameter-estimation-techniques.html#cb40-54"></a>  ordered_gamma_vector_matrix &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(ordered_gamma_vector_matrix)</span>
<span id="cb40-55"><a href="parameter-estimation-techniques.html#cb40-55"></a>  </span>
<span id="cb40-56"><a href="parameter-estimation-techniques.html#cb40-56"></a>  result &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">lambda =</span> ordered_lambda,</span>
<span id="cb40-57"><a href="parameter-estimation-techniques.html#cb40-57"></a>                 <span class="dt">gamma =</span> ordered_gamma,</span>
<span id="cb40-58"><a href="parameter-estimation-techniques.html#cb40-58"></a>                 <span class="dt">delta =</span> ordered_delta,</span>
<span id="cb40-59"><a href="parameter-estimation-techniques.html#cb40-59"></a>                 <span class="dt">lambda_std_error =</span> ordered_lambda_std_error,</span>
<span id="cb40-60"><a href="parameter-estimation-techniques.html#cb40-60"></a>                 <span class="dt">gamma_std_error =</span> ordered_gamma_std_error,</span>
<span id="cb40-61"><a href="parameter-estimation-techniques.html#cb40-61"></a>                 <span class="dt">delta_std_error =</span> ordered_delta_std_error,</span>
<span id="cb40-62"><a href="parameter-estimation-techniques.html#cb40-62"></a>                 <span class="dt">ordered_lambda_indices =</span> ordered_lambda_indices,</span>
<span id="cb40-63"><a href="parameter-estimation-techniques.html#cb40-63"></a>                 <span class="dt">ordered_gamma_vector_indices =</span> ordered_gamma_vector_matrix,</span>
<span id="cb40-64"><a href="parameter-estimation-techniques.html#cb40-64"></a>                 <span class="co"># delta and lambda are the same size, so they are ordered the same way</span></span>
<span id="cb40-65"><a href="parameter-estimation-techniques.html#cb40-65"></a>                 <span class="dt">ordered_delta_indices =</span> ordered_lambda_indices)</span>
<span id="cb40-66"><a href="parameter-estimation-techniques.html#cb40-66"></a>  </span>
<span id="cb40-67"><a href="parameter-estimation-techniques.html#cb40-67"></a>  <span class="co"># Remove the NULL elements</span></span>
<span id="cb40-68"><a href="parameter-estimation-techniques.html#cb40-68"></a>  result[<span class="kw">sapply</span>(result, is.null)] &lt;-<span class="st"> </span><span class="ot">NULL</span></span>
<span id="cb40-69"><a href="parameter-estimation-techniques.html#cb40-69"></a>  </span>
<span id="cb40-70"><a href="parameter-estimation-techniques.html#cb40-70"></a>  <span class="kw">return</span>(result)</span>
<span id="cb40-71"><a href="parameter-estimation-techniques.html#cb40-71"></a>}</span></code></pre></div>
<p>We will go through an example to better understand the process.
For readability, the TPM is filled with standard row and column indexes instead of probabilities.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="parameter-estimation-techniques.html#cb41-1"></a>lambda &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb41-2"><a href="parameter-estimation-techniques.html#cb41-2"></a>gamma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>,</span>
<span id="cb41-3"><a href="parameter-estimation-techniques.html#cb41-3"></a>                  <span class="dv">21</span>, <span class="dv">22</span>, <span class="dv">23</span>,</span>
<span id="cb41-4"><a href="parameter-estimation-techniques.html#cb41-4"></a>                  <span class="dv">31</span>, <span class="dv">32</span>, <span class="dv">33</span>), <span class="dt">byrow =</span> <span class="ot">TRUE</span>, <span class="dt">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb41-5"><a href="parameter-estimation-techniques.html#cb41-5"></a><span class="kw">pois.HMM.label.order</span>(<span class="dt">m =</span> <span class="dv">3</span>, lambda, gamma)</span></code></pre></div>
<pre><code>## $lambda
## [1] 1 2 3
## 
## $gamma
##      [,1] [,2] [,3]
## [1,]   33   31   32
## [2,]   13   11   12
## [3,]   23   21   22
## 
## $delta
## [1] -0.032786885  0.016393443 -0.008196721
## 
## $ordered_lambda_indices
## [1] 2 3 1
## 
## $ordered_gamma_vector_indices
## [1] 9 7 8 3 1 2 6 4 5
## 
## $ordered_delta_indices
## [1] 2 3 1</code></pre>
<p>State 1 has been relabeled state 3, state 3 became state 2, and state 2 became state 1.</p>
<p>Another way to address this issue is by parametrizing in terms of non-negative increments <span class="math inline">\(\lambda_j - \lambda_{j-1}\)</span> with <span class="math inline">\(\lambda_0 \equiv 0\)</span>, as explained by <span class="citation">(Zucchini, MacDonald, and Langrock <a href="#ref-zucchini" role="doc-biblioref">2016</a> Section 7.1.1 p. 112)</span>.
However, <span class="citation">(Bulla and Berzel <a href="#ref-bulla" role="doc-biblioref">2008</a>, Section 3.2 p. 7)</span> shows this can impose optimization issues. They write “We find that, over all series, the simplest parameterization, i.e., the use of log-transformed state-dependent parameters, leads to the best results as regards the number of failures and the convergence to the global maximum”.</p>

<!-- ```{r 4import-files, echo = FALSE, cache = FALSE} -->
<!-- library(knitr) -->
<!-- setwd(dir = "../") -->
<!-- # suppressMessages(source("code/main.R")) -->
<!-- knitr::read_chunk('functions/utils.R') -->
<!-- ``` -->
</div>
</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-bulla">
<p>Bulla, Jan, and Andreas Berzel. 2008. “Computational Issues in Parameter Estimation for Stationary Hidden Markov Models.” <em>Computational Statistics</em> 23 (1): 1–18. <a href="https://doi.org/10.1007/s00180-007-0063-y">https://doi.org/10.1007/s00180-007-0063-y</a>.</p>
</div>
<div id="ref-zucchini">
<p>Zucchini, W., I. L. MacDonald, and R. Langrock. 2016. <em>Hidden Markov Models for Time Series: An Introduction Using R, Second Edition</em>. Chapman &amp; Hall/CRC Monographs on Statistics &amp; Applied Probability. CRC Press. <a href="https://books.google.no/books?id=KlWzDAAAQBAJ">https://books.google.no/books?id=KlWzDAAAQBAJ</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="principles-of-using-tmb-for-maximum-likelihood-estimation.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="using-tmb.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Data supplements.pdf", "Data supplements.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
